import{_ as e,o as l,c as o,V as a}from"./chunks/framework.75ed6a74.js";const s=JSON.parse('{"title":"js 基础知识","description":"","frontmatter":{},"headers":[{"level":2,"title":"函数调用栈","slug":"函数调用栈","link":"#函数调用栈","children":[]},{"level":2,"title":"V8 垃圾回收","slug":"v8-垃圾回收","link":"#v8-垃圾回收","children":[{"level":3,"title":"垃圾回收机制分为：新生代、老年代","slug":"垃圾回收机制分为-新生代、老年代","link":"#垃圾回收机制分为-新生代、老年代","children":[]},{"level":3,"title":"主垃圾回收器 标记->清理->紧凑","slug":"主垃圾回收器-标记-清理-紧凑","link":"#主垃圾回收器-标记-清理-紧凑","children":[]},{"level":3,"title":"Orinoco 的垃圾回收器的三个优化","slug":"orinoco-的垃圾回收器的三个优化","link":"#orinoco-的垃圾回收器的三个优化","children":[]},{"level":3,"title":"空闲时垃圾回收","slug":"空闲时垃圾回收","link":"#空闲时垃圾回收","children":[]}]}],"relativePath":"frontend/js/js-adjust-process.md","filePath":"frontend/js/js-adjust-process.md"}'),c={name:"frontend/js/js-adjust-process.md"},n=[a('<h1 id="js-基础知识" tabindex="-1">js 基础知识 <a class="header-anchor" href="#js-基础知识" aria-label="Permalink to &quot;js 基础知识&quot;">​</a></h1><h2 id="函数调用栈" tabindex="-1">函数调用栈 <a class="header-anchor" href="#函数调用栈" aria-label="Permalink to &quot;函数调用栈&quot;">​</a></h2><p>用 ESP 指针来保存当前的执行状态</p><h2 id="v8-垃圾回收" tabindex="-1">V8 垃圾回收 <a class="header-anchor" href="#v8-垃圾回收" aria-label="Permalink to &quot;V8 垃圾回收&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在 64 位系统下，V8 最多只能分配 1.4G, 在 32 位系统中，最多只能分配 0.7G 对于栈内存而言，当 ESP 指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了，我们下面着重分析堆内存的垃圾回收。</p></div><p>所有的对象类型的数据在 JS 中都是通过堆进行空间分配的</p><p>V8 为什么要给它设置内存上限？</p><p>是由两个因素所共同决定的，一个是 JS 单线程的执行机制，另一个是 JS 垃圾回收机制的限制。</p><p>首先 JS 是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，那么在这么长的时间内，我们的 JS 代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 也可以通过命令调整内存限制的大小</span></span>\n<span class="line"><span style="color:#A6ACCD;">node </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">max</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">old</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">space</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">size</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">2048</span><span style="color:#A6ACCD;"> xxx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>\n<span class="line"><span style="color:#A6ACCD;">node </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">max</span><span style="color:#89DDFF;">-new-</span><span style="color:#A6ACCD;">space</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">size</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">2048</span><span style="color:#A6ACCD;"> xxx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="垃圾回收机制分为-新生代、老年代" tabindex="-1">垃圾回收机制分为：新生代、老年代 <a class="header-anchor" href="#垃圾回收机制分为-新生代、老年代" aria-label="Permalink to &quot;垃圾回收机制分为：新生代、老年代&quot;">​</a></h3><ul><li><code>新生代</code>就是临时分配的内存，存活时间短，</li><li><code>老生代</code>是常驻内存，存活的时间长。</li><li><code>V8 的堆内存</code>：就是两个内存之和。</li></ul><h4 id="新生代的垃圾回收-新生代内存空间一分为二-标记-复制-清理-scavenge-算法" tabindex="-1">新生代的垃圾回收：新生代内存空间一分为二，标记-&gt;复制-&gt;清理(Scavenge 算法) <a class="header-anchor" href="#新生代的垃圾回收-新生代内存空间一分为二-标记-复制-清理-scavenge-算法" aria-label="Permalink to &quot;新生代的垃圾回收：新生代内存空间一分为二，标记-&gt;复制-&gt;清理(Scavenge 算法)&quot;">​</a></h4><ul><li><p><code>From space</code> 、<code>To space</code> 都有<code>工作状态</code>和<code>空闲状态</code></p></li><li><p>部分表示正在使用的内存，是目前闲置的内存。</p></li><li><p>比如我们新创建一个对象：</p><ol><li>会向内存堆中的新生代去分配，假如此时新生代中的 <code>from spcae</code> 是工作状态，那么对象会分配到 from space 中。</li><li>经过一段时间程序运行，<code>from space</code> 的的内存即将达到存储的上限。</li><li>V8 引擎此时执行一次垃圾清理操作，会将 from space 中不再使用的对象（根节点无法遍历到的对象）<code>进行标记</code>。</li><li>会将未被标记的对象进行复制，复制到空闲状态的 <code>to space</code> 中并且有序的重新排列起来，再将 <code>from space</code> 进行<code>清空</code>操作，同时将 <code>from space</code> 标记为<code>空闲状态</code>将 <code>to space</code> 标记为<code>工作状态</code>。</li><li>V8 采用了 <code>晋升机制</code> 将满足条件的对象放到老生代内存区中存储，释放新生代内存区域的空间。即：经历过一次 Scavenging 算法，且并未被标记清除的，也就是过一次翻转置换操作的对象；翻转置换时，被复制的对象大于 to space 空间的 25%即可晋升</li></ol></li></ul><h3 id="主垃圾回收器-标记-清理-紧凑" tabindex="-1">主垃圾回收器 标记-&gt;清理-&gt;紧凑 <a class="header-anchor" href="#主垃圾回收器-标记-清理-紧凑" aria-label="Permalink to &quot;主垃圾回收器 标记-&gt;清理-&gt;紧凑&quot;">​</a></h3><ul><li>主垃圾回收器会先使用标记 - 清除（Mark-Sweep）的算法进行垃圾回收。 <ul><li>标记阶段是：从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能<code>到达的元素</code>称为活动对象，<code>没有到达的元素</code>就可以判断为<code>垃圾数据</code>。</li><li>清除过程：它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据<code>清理掉</code>。</li></ul></li><li>标记 - 整理（Mark-Compact） <ul><li>首先同样是标记过程。</li><li>将未标记的对象（存活对象）进行<code>左移</code>，移动完成后<code>清理边界外的内存</code>。</li></ul></li></ul><h3 id="orinoco-的垃圾回收器的三个优化" tabindex="-1">Orinoco 的垃圾回收器的三个优化 <a class="header-anchor" href="#orinoco-的垃圾回收器的三个优化" aria-label="Permalink to &quot;Orinoco 的垃圾回收器的三个优化&quot;">​</a></h3><ul><li>并行垃圾回收 (parallel)：开启辅助几个辅助进程同时完成垃圾清理的工作</li><li>增量垃圾回收 (incremental)：对大的对象一次执行标记花很长的时间 <ul><li>V8 采用了 <code>标记位</code> 和 <code>标记工作表</code> 来实现标记</li><li><code>白色</code> 是未被根节点引用到的对象</li><li><code>灰色</code> 对象被引用，并将其推入到 标记工作表 中</li><li>标记工作表 会访问所有<code>存在自身的</code> <code>灰色</code> 对象，并访问该对象的<code>所有子对象</code>，结束后会将该对象标记为<code>黑色</code>。</li><li>标记工作表 会持续的<code>被注入灰色的对象</code>（每发现一个新的要标记的对象都会注入到标记工作表中）</li><li>如果 标记工作表 中 没有了<code>灰色</code> 的对象，那么代表所有的对象都是 <code>黑色</code> 或者 <code>白色</code>，之后可以放心的清理掉 <code>白色</code> 的对象。</li><li>被主线程修改了，如何正确的处理？ V8 使用了写屏障（write-barrier） 机制来实现</li></ul></li><li>并发垃圾回收 (concurrent)</li></ul><h3 id="空闲时垃圾回收" tabindex="-1">空闲时垃圾回收 <a class="header-anchor" href="#空闲时垃圾回收" aria-label="Permalink to &quot;空闲时垃圾回收&quot;">​</a></h3>',19)];const i=e(c,[["render",function(e,a,s,c,i,d){return l(),o("div",null,n)}]]);export{s as __pageData,i as default};
