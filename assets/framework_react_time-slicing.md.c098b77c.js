import{_ as i}from"./chunks/browser-frame.8abcb6e1.js";import{_ as e,o as l,c as r,V as a}from"./chunks/framework.75ed6a74.js";const s=JSON.parse('{"title":"time slicing","description":"","frontmatter":{},"headers":[],"relativePath":"framework/react/time-slicing.md","filePath":"framework/react/time-slicing.md"}'),t={name:"framework/react/time-slicing.md"},m=[a('<h1 id="time-slicing" tabindex="-1">time slicing <a class="header-anchor" href="#time-slicing" aria-label="Permalink to &quot;time slicing&quot;">​</a></h1><p>时间切片</p><p>我们看看浏览器里的一帧发生了什么。我们知道，通常情况下，浏览器的一帧为 16.7ms。由于 js 是单线程，那么它内部的一些事件，比如 click 事件，宏任务，微任务，requestAnimatinFrame，requestIdleCallback 等等都会在浏览器帧里按一定的顺序去执行。具体的执行顺序如下：</p><p><img src="'+i+'" alt="browser-frame"></p><p>浏览器一帧里回调的执行顺序为：</p><ol><li>用户事件：最先执行，比如 click 等事件。</li><li>js 代码：宏任务和微任务，这段时间里可以执行多个宏任务，但是必须把微任务队列执行完成。宏任务会被浏览器自动调控。比如浏览器如果觉得宏任务执行时间太久，它会将下一个宏任务分配到下一帧中，避免掉帧。</li><li>在渲染前执行 scroll/resize 等事件回调。</li><li>在渲染前执行 requestAnimationFrame 回调。</li><li>渲染界面：面试中经常提到的浏览器渲染时 html、css 的计算布局绘制等都是在这里完成。</li><li>requestIdleCallback 执行回调：如果前面的那些任务执行完成了，一帧还剩余时间，那么会调用该函数。</li></ol><p>因为 requestIdleCallback 兼容性比较差</p><p>React 团队自己实现一个类似的功能：时间切片（time slicing）。</p><p>上图的 Timer 部分（js 执行部分），取 5ms 做分片执行，执行超过 5ms，就不再执行了。</p>',9)];const c=e(t,[["render",function(i,e,a,s,t,c){return l(),r("div",null,m)}]]);export{s as __pageData,c as default};
