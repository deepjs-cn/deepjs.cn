import{_ as l,o as i,c as e,V as o}from"./chunks/framework.75ed6a74.js";const t=JSON.parse('{"title":"性能优化","description":"","frontmatter":{},"headers":[{"level":2,"title":"前端性能优化系列","slug":"前端性能优化系列","link":"#前端性能优化系列","children":[{"level":3,"title":"Checklist","slug":"checklist","link":"#checklist","children":[]}]}],"relativePath":"system-design/performance-optimize/index.md","filePath":"system-design/performance-optimize/index.md"}'),a={name:"system-design/performance-optimize/index.md"},r=[o('<h1 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h1><h2 id="前端性能优化系列" tabindex="-1">前端性能优化系列 <a class="header-anchor" href="#前端性能优化系列" aria-label="Permalink to &quot;前端性能优化系列&quot;">​</a></h2><h3 id="checklist" tabindex="-1">Checklist <a class="header-anchor" href="#checklist" aria-label="Permalink to &quot;Checklist&quot;">​</a></h3><ol><li>加载链路优化</li><li>加载体积优化</li><li>运行时性能优化 <ol><li>感官体验优化</li><li>渲染执行性能优化</li></ol></li></ol><p>监控指标</p><ol><li>性能监控 <ol><li>dns</li><li>fp</li><li>fmp/lcp</li><li>ready</li><li>onload</li><li>资源加载耗时</li><li>API 请求耗时</li></ol></li></ol><p>性能优化不局限于首屏时间</p><p>目前指标：</p><ul><li>首屏时间满意度</li><li>首次渲染时间</li></ul><p>前端性能优化分析：</p><ol><li>从输入 url 到页面展示经历了哪些流程？</li><li>指标 <ol><li>真实指标</li><li>实验室指标</li><li>评估工具</li></ol></li><li>优化环节及方案 <ol><li>加载链路优化</li><li>加载体积优化</li><li>感官体验优化</li><li>执行渲染优化</li></ol></li><li>思考：性能优化对业务的影响</li></ol><p>优化之前，先确定衡量的指标，比如</p><ul><li>优化项针对 FPT 或 FMP，速度优化了多少？</li><li>优化项针对打包体积，体积优化了多少？对加载速度有影响？</li></ul><ol><li>加载链路优化 <ol><li>DNS 预解析、预加载 <ol><li>域名收敛</li><li>link 标签的 rel 属性 dns-prefetch</li><li>httpdns(自家 app)</li></ol></li><li>HTTP 缓存 2022-11-11 <ol><li>Service Worker</li><li>强缓存</li><li>协商缓存</li><li>工程化辅助支持（稳定性 hash, 延长强缓存有效性）</li></ol></li><li>TCP 链接与 HTTP 协议 <ol><li>HTTP/1.1 <ol><li>keep alive 长连接</li><li>域名发散，图片并发请求限制</li><li>雪碧图</li></ol></li><li>HTTP/2 多路复用</li><li>HTTP/3</li><li>打包代码</li></ol></li><li>发送请求 <ol><li>减少请求数</li><li>小图片使用 base64 免去请求</li><li>网络请求优先级</li><li>资源 <ol><li>prefetch</li><li>preload</li><li>非核心代码异步加载，如低优先级三方代码</li></ol></li><li>页面 <ol><li>prerender</li></ol></li><li>请求合并 <ol><li>资源请求合并</li><li>API 请求合并</li></ol></li></ol></li><li>服务器处理请求 <ol><li>减少/避免重定向 301 永久/302 临时</li><li>使用 HSTS 强制 https，<a href="https://www.cnblogs.com/cswuyg/p/3871976.html" target="_blank" rel="noreferrer">307 临时</a></li></ol></li><li>发送响应 <ol><li>gzip 压缩资源</li><li>更好的格式 如 webp</li></ol></li><li>加载距离优化 <ol><li>使用 CDN（内容分发网络）, 加速下载</li><li>预加载处理（自家 APP 内置资源/离线包）</li></ol></li><li>接口请求时间优化</li><li>首屏接口</li><li>合并接口</li><li>缓存接口</li><li>请求耗时分析</li><li>服务端渲染</li></ol></li><li>加载体积优化（能不加载就不加载、能少加载的就少加载） <ol><li>按需加载、懒加载 <ol><li>路由懒加载</li><li>模块懒加载(按需使用，模块过小，就不需要使用)</li><li>非首屏懒加载</li></ol></li><li>优化打包体积 2022-12-16 <ol><li>代码压缩 <ol><li>HTML <ol><li>HtmlwebpackPlugin</li><li>html-minifier-terser</li></ol></li><li>CSS <ol><li>压缩 css-minimizer-webpack-plugin</li><li>tree-shaking（purgecss-plugin-webpack）</li><li>抽取 css mini-css-extract-plugin</li></ol></li><li>JS <ol><li>terser-webpack-plugin</li><li>tree shaking (配置 optimization:{usedExports: true} 还有 sideEffecis)</li></ol></li></ol></li><li>优化 core-js、polyfill，合理的 .browserslistrc <ol><li>transform-runtime 减少 ES6 转化 ES5 的冗余</li></ol></li><li>选用合适的 lib 库，如 moment → dayjs</li><li>合理的分包策略 splitChunks</li><li>避免版本依赖滥用（多个相似的 npm 包）</li></ol></li><li>传输压缩 <ol><li>Gzip</li><li>Brotli</li><li>预压缩（compression-webpack-plugin -&gt; gzip 等）</li></ol></li><li>图片、图片及字体优化 <ol><li>合适的文件格式（git,png8,png24,jpg,svg,webp,apng） <ol><li>使用渐进式 jpeg</li><li><a href="%5Bhttps://pag.art">pag</a>](<a href="https://pag.art" target="_blank" rel="noreferrer">https://pag.art</a>%29/)</li></ol></li><li>为不同分辨率提供不同的图片尺寸</li><li>压缩图片 <a href="https://tinypng.com" target="_blank" rel="noreferrer">https://tinypng.com</a></li><li>图片懒加载 IntersectionObserver</li><li>小图优化 雪碧图、iconfont、svg <ol><li>使用 iconfont 代替图片图标</li><li>图片会增加网络次数</li></ol></li><li>优化 svg <ol><li>svg-sprite-loader</li><li>svgo-loader</li></ol></li></ol></li></ol></li><li>感官体验优化 <ol><li>骨架屏</li><li>loading 动画（白屏时或路由跳转时）</li><li>加载占位图</li><li>渐进加载图片 <ol><li>先加载小图，模糊化显示，图片加载完成后替换为原图</li></ol></li><li>响应顺序优化 <ol><li>首屏优化</li><li>bigpipe</li></ol></li><li>接口缓存与 SWR（stale-while-revalidate）</li></ol></li><li>运行时优化 <ol><li>HTML</li><li>CSS <ol><li>减少嵌套，最多不超过三层或四层</li><li>避免使用通配符</li><li>利用继承</li><li>正确使用类选择器和 id 选择器</li><li>适用 css3 效果代替图片</li></ol></li><li>减少重绘和回流 <ol><li>多个节点使用 documentFragment：不是真实 dom 的部分，不会引起重绘和回流</li><li>适用以下替代属性 <ol><li>top -&gt; translate</li><li>display: none -&gt; visibility 减少回流</li><li>visiability -&gt; opacity 减少重绘</li></ol></li><li>Dom 离线后修改，先改为 display: none, 再修改 100 次后显示</li><li>不要循环中取 dom 的属性</li><li>将频繁运行的动画变为图层</li></ol></li><li>JS <ol><li>合理使用缓存机制，缓存计算结果，减少计算次数</li><li>适用事件委托</li><li>css3 动画和 canvas 动画比 js 动画性能好</li><li>复杂计算开启 webWorker，避免页面假死</li><li>减少同步加载</li><li>减少同步操作、执行</li><li>防抖与节流</li><li>虚拟列表优化</li></ol></li><li>流畅动画 <ol><li>requestAnimationFrame</li></ol></li><li>Vue <ol><li>v-for 添加 key</li><li>路由懒加载</li><li>第三方插件按需引入</li><li>合理使用 computer 和 watch</li><li>destory 时销毁事件 addEventListener setTimeout 等</li></ol></li><li>React <ol><li>map 循环展示添加 key</li><li>路由懒加载</li><li>第三方插件按需引入</li><li>使用 scu, memo 或 pureComponent 避免不必要的渲染</li><li>合理使用 memo, useMemo, useCallback <ol><li>他们三个的应用场景都是缓存结果，当依赖值没有改变时避免不必要的计算或者渲染。</li><li>useCallback 是针对函数进行“记忆”的，当它依赖项没有发生改变时，那么该函数的引用并不会随着组件的刷新而被重新赋值。当我们觉得一个函数不需要随着组件的更新而更新引用地址的时候，我们就可以使用 useCallback 去修饰它。</li><li>React.memo 是对组件进行 “记忆”，当它接收的 props 没有发生改变的时候，那么它将返回上次渲染的结果，不会重新执行函数返回新的渲染结果。</li><li>React.useMemo 是针对 值计算 的一种“记忆“，当依赖项没有发生改变时，那么无需再去计算，直接使用之前的值，对于组件而言，这带来的一个好处就是，可以减少一些计算，避免一些多余的渲染。当我们遇到一些数据需要在组件内部进行计算的时候，可以考虑一下 React.useMemo</li></ol></li></ol></li></ol></li></ol>',14)];const s=l(a,[["render",function(l,o,t,a,s,n){return i(),e("div",null,r)}]]);export{t as __pageData,s as default};
