(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{198:function(t,v,_){t.exports=_.p+"assets/img/big-o-graph.9c24f10d.png"},286:function(t,v,_){"use strict";_.r(v);var e={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},a=_(2),r=Object(a.a)(e,function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[e("h1",{attrs:{id:"算法与数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法与数据结构","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法与数据结构")]),t._v(" "),e("p",[t._v("参照"),e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 算法与数据结构"),e("OutboundLink")],1),t._v("，结合自己的理解，操作一遍各类目")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 算法与数据结构 - 中文版"),e("OutboundLink")],1)]),t._v(" "),e("li",[t._v("https://github.com/imhuay/Algorithm_Interview_Notes-Chinese")])]),t._v(" "),e("h2",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),e("p",[t._v("数据结构是在计算机中 组织和存储数 据的一种特殊方式, 它可以高效地 访问和修改 数据。更确切地说, 数据结构是数据值的集合, 它们之间的关系、函数或操作可以应用于数据。")]),t._v(" "),e("p",[e("code",[t._v("B")]),t._v(" - 初学者, "),e("code",[t._v("A")]),t._v(" - 进阶")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./data-structures/linked-list"}},[t._v("链表")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./data-structures/doubly-linked-list"}},[t._v("双向链表")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./data-structures/queue"}},[t._v("队列")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./data-structures/stack"}},[t._v("栈")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./data-structures/hash-table"}},[t._v("哈希表")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./data-structures/heap"}},[t._v("堆")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./data-structures/priority-queue"}},[t._v("优先队列")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/trie"}},[t._v("字典树")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/tree"}},[t._v("树")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/tree/binary-search-tree"}},[t._v("二叉查找树")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/tree/avl-tree"}},[t._v("AVL 树")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/tree/red-black-tree"}},[t._v("红黑树")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/tree/segment-tree"}},[t._v("线段树")]),t._v(" - 使用 最小/最大/总和 范围查询示例")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/tree/fenwick-tree"}},[t._v("树状数组")]),t._v(" (二叉索引树)")])])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/graph"}},[t._v("图")]),t._v(" (有向图与无向图)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/disjoint-set"}},[t._v("并查集")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./data-structures/bloom-filter"}},[t._v("布隆过滤器")])])]),t._v(" "),e("h2",{attrs:{id:"算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),e("p",[t._v("算法是如何解决一类问题的明确规范。 算法是一组精确定义操作序列的规则。")]),t._v(" "),e("h3",{attrs:{id:"算法主题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法主题","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法主题")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("数学")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/bits"}},[t._v("Bit 操控")]),t._v(" - set/get/update/clear 位, 乘以/除以 二进制位, 变负 等.")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/factorial"}},[t._v("阶乘")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/fibonacci"}},[t._v("斐波那契数")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/primality-test"}},[t._v("素数检测")]),t._v(" (排除法)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/euclidean-algorithm"}},[t._v("欧几里得算法")]),t._v(" - 计算最大公约数 (GCD)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/least-common-multiple"}},[t._v("最小公倍数")]),t._v(" (LCM)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/sieve-of-eratosthenes"}},[t._v("素数筛")]),t._v(" - 查找所有素数达到任何给定限制")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/is-power-of-two"}},[t._v("判断2次方数")]),t._v(" - 检查数字是否为2的幂 (原生和按位算法)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/pascal-triangle"}},[t._v("杨辉三角形")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/integer-partition"}},[t._v("整数拆分")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/liu-hui"}},[t._v("割圆术")]),t._v(" - 基于N-gons的近似π计算")])])]),t._v(" "),e("li",[e("strong",[t._v("集合")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/cartesian-product"}},[t._v("笛卡尔积")]),t._v(" - 多集合结果")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/power-set"}},[t._v("幂集")]),t._v(" - 该集合的所有子集")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/permutations"}},[t._v("排列")]),t._v(" (有/无重复)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/combinations"}},[t._v("组合")]),t._v(" (有/无重复)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/fisher-yates"}},[t._v("洗牌算法")]),t._v(" - 随机置换有限序列")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/longest-common-subsequence"}},[t._v("最长公共子序列")]),t._v(" (LCS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/longest-increasing-subsequence"}},[t._v("最长递增子序列")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/shortest-common-supersequence"}},[t._v("最短公共父序列")]),t._v(" (SCS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/knapsack-problem"}},[t._v("背包问题")]),t._v(' - "0/1" and "Unbound" ones')]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/maximum-subarray"}},[t._v("最大子数列问题")]),t._v(" - BF算法 与 动态规划")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/combination-sum"}},[t._v("组合求和")]),t._v(" - 查找形成特定总和的所有组合")])])]),t._v(" "),e("li",[e("strong",[t._v("字符串")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/levenshtein-distance"}},[t._v("莱温斯坦距离")]),t._v(" - 两个序列之间的最小编辑距离")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/hamming-distance"}},[t._v("汉明距离")]),t._v(" - 符号不同的位置数")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/knuth-morris-pratt"}},[t._v("克努斯-莫里斯-普拉特算法")]),t._v(" - 子串搜索")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/rabin-karp"}},[t._v("字符串快速查找")]),t._v(" - 子串搜索")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/longest-common-substring"}},[t._v("最长公共子串")])]),t._v(" "),e("li",[e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/regular-expression-matching"}},[t._v("正则表达式匹配")])])])]),t._v(" "),e("li",[e("strong",[t._v("搜索")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/search/linear-search"}},[t._v("线性搜索")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/search/jump-search"}},[t._v("跳转搜索")]),t._v("  (或块搜索)  - 搜索排序数组")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/search/binary-search"}},[t._v("二分查找")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/search/interpolation-search"}},[t._v("插值搜索")]),t._v(" - 搜索均匀分布的排序数组")])])]),t._v(" "),e("li",[e("strong",[t._v("排序")]),t._v(" "),e("ul",[e("li",[t._v("[x] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/bubble-sort.js"}},[t._v("冒泡排序")])]),t._v(" "),e("li",[t._v("[x] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/selection-sort.js"}},[t._v("选择排序")])]),t._v(" "),e("li",[t._v("[x] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/insertion-sort.js"}},[t._v("插入排序")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/heap-sort.js"}},[t._v("堆排序")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/merge-sort.js"}},[t._v("归并排序")])]),t._v(" "),e("li",[t._v("[x] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/quick-sort.js"}},[t._v("快速排序")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/shell-sort.js"}},[t._v("希尔排序")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/counting-sort.js"}},[t._v("计数排序")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/radix-sort.js"}},[t._v("基数排序")])])])]),t._v(" "),e("li",[e("strong",[t._v("树")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/tree/depth-first-search"}},[t._v("深度优先搜索")]),t._v(" (DFS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/tree/breadth-first-search"}},[t._v("广度优先搜索")]),t._v(" (BFS)")])])]),t._v(" "),e("li",[e("strong",[t._v("图")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/depth-first-search"}},[t._v("深度优先搜索")]),t._v(" (DFS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/breadth-first-search"}},[t._v("广度优先搜索")]),t._v(" (BFS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/dijkstra"}},[t._v("戴克斯特拉算法")]),t._v(" - 找到图中所有顶点的最短路径")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/bellman-ford"}},[t._v("贝尔曼-福特算法")]),t._v(" - 找到图中所有顶点的最短路径")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/floyd-warshall"}},[t._v("弗洛伊德算法")]),t._v(" - 找到所有顶点对 之间的最短路径")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/detect-cycle"}},[t._v("判圈算法")]),t._v(" - 对于有向图和无向图 (基于DFS和不相交集的版本)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/prim"}},[t._v("普林演算法")]),t._v(" - 寻找加权无向图的最小生成树 (MST)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/kruskal"}},[t._v("克鲁斯克尔演算法")]),t._v(" - 寻找加权无向图的最小生成树 (MST)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/topological-sorting"}},[t._v("拓扑排序")]),t._v(" - DFS 方法")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/articulation-points"}},[t._v("关节点")]),t._v(" - Tarjan算法 (基于DFS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/bridges"}},[t._v("桥")]),t._v(" - 基于DFS的算法")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/eulerian-path"}},[t._v("欧拉回径与一笔画问题")]),t._v(" - Fleury的算法 - 一次访问每个边")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/hamiltonian-cycle"}},[t._v("哈密顿图")]),t._v(" - 恰好访问每个顶点一次")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/strongly-connected-components"}},[t._v("强连通分量")]),t._v(" - Kosaraju算法")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/travelling-salesman"}},[t._v("旅行推销员问题")]),t._v(" - 尽可能以最短的路线访问每个城市并返回原始城市")])])]),t._v(" "),e("li",[e("strong",[t._v("未分类")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/hanoi-tower"}},[t._v("汉诺塔")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/square-matrix-rotation"}},[t._v("旋转矩阵")]),t._v(" - 原地算法")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/jump-game"}},[t._v("跳跃 游戏")]),t._v(" - 回溯, 动态编程 (自上而下+自下而上) 和贪婪的例子")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/unique-paths"}},[t._v("独特(唯一) 路径")]),t._v(" - 回溯, 动态编程和基于Pascal三角形的例子")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/rain-terraces"}},[t._v("雨水收集")]),t._v(" - 诱捕雨水问题 (动态编程和暴力版本)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/n-queens"}},[t._v("八皇后问题")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/knight-tour"}},[t._v("骑士巡逻")])])])])]),t._v(" "),e("h3",{attrs:{id:"算法范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法范式","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法范式")]),t._v(" "),e("p",[t._v("算法范式是基于类的设计的通用方法或方法的算法。 这是一个比算法概念更高的抽象, 就像一个\n算法是比计算机程序更高的抽象。")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("BF算法")]),t._v(" - 查找/搜索 所有可能性并选择最佳解决方案")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/search/linear-search"}},[t._v("线性搜索")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/rain-terraces"}},[t._v("雨水收集")]),t._v(" - 诱导雨水问题")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/maximum-subarray"}},[t._v("最大子数列")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/travelling-salesman"}},[t._v("旅行推销员问题")]),t._v(" - 尽可能以最短的路线访问每个城市并返回原始城市")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("贪心法")]),t._v(" - 在当前选择最佳选项, 不考虑以后情况")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/jump-game"}},[t._v("跳跃游戏")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/knapsack-problem"}},[t._v("背包问题")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/dijkstra"}},[t._v("戴克斯特拉算法")]),t._v(" - 找到所有图顶点的最短路径")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/prim"}},[t._v("普里姆算法")]),t._v(" - 寻找加权无向图的最小生成树 (MST)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/kruskal"}},[t._v("克鲁斯卡尔算法")]),t._v(" - 寻找加权无向图的最小生成树 (MST)")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("分治法")]),t._v(" - 将问题分成较小的部分, 然后解决这些部分")]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/search/binary-search"}},[t._v("二分查找")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/hanoi-tower"}},[t._v("汉诺塔")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/pascal-triangle"}},[t._v("杨辉三角形")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/euclidean-algorithm"}},[t._v("欧几里得算法")]),t._v(" - 计算最大公约数 (GCD)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/jump-game"}},[t._v("跳跃游戏")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/merge-sort"}},[t._v("归并排序")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sorting/quick-sort"}},[t._v("快速排序")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/tree/depth-first-search"}},[t._v("树深度优先搜索")]),t._v(" (DFS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/depth-first-search"}},[t._v("图深度优先搜索")]),t._v(" (DFS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/permutations"}},[t._v("排列")]),t._v(" (有/无重复)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/combinations"}},[t._v("组合")]),t._v(" (有/无重复)")])])])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("动态编程")]),t._v(" - 使用以前找到的子解决方案构建解决方案")])]),t._v(" "),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/fibonacci"}},[t._v("斐波那契数")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/jump-game"}},[t._v("跳跃游戏")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/unique-paths"}},[t._v("独特路径")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/rain-terraces"}},[t._v("雨水收集")]),t._v(" - 疏导雨水问题")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/levenshtein-distance"}},[t._v("莱温斯坦距离")]),t._v(" - 两个序列之间的最小编辑距离")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/longest-common-subsequence"}},[t._v("最长公共子序列")]),t._v(" (LCS)")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/string/longest-common-substring"}},[t._v("最长公共子串")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/longest-increasing-subsequence"}},[t._v("最长递增子序列")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/shortest-common-supersequence"}},[t._v("最短公共子序列")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/knapsack-problem"}},[t._v("0-1背包问题")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/math/integer-partition"}},[t._v("整数拆分")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/maximum-subarray"}},[t._v("最大子数列")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/floyd-warshall"}},[t._v("弗洛伊德算法")]),t._v(" - 找到所有顶点对之间的最短路径")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/bellman-ford"}},[t._v("贝尔曼-福特算法")]),t._v(" - 找到所有图顶点的最短路径")]),t._v(" "),e("li",[e("strong",[t._v("回溯法")]),t._v(" - 类似于 BF算法 试图产生所有可能的解决方案, 但每次生成解决方案测试如果它满足所有条件, 那么只有继续生成后续解决方案。 否则回溯并继续寻找不同路径的解决方案。\n"),e("ul",[e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/jump-game"}},[t._v("跳跃游戏")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("B")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/unique-paths"}},[t._v("独特路径")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/graph/hamiltonian-cycle"}},[t._v("哈密顿图")]),t._v(" - 恰好访问每个顶点一次")]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/n-queens"}},[t._v("八皇后问题")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/uncategorized/knight-tour"}},[t._v("骑士巡逻")])]),t._v(" "),e("li",[t._v("[ ] "),e("code",[t._v("A")]),t._v(" "),e("a",{attrs:{href:"./algorithms/sets/combination-sum"}},[t._v("组合求和")]),t._v(" - 从规定的总和中找出所有的组合")])])]),t._v(" "),e("li",[e("strong",[t._v("Branch & Bound")])])]),t._v(" "),e("h2",{attrs:{id:"算法复杂度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法复杂度","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法复杂度")]),t._v(" "),e("ul",[e("li",[t._v("时间复杂度")]),t._v(" "),e("li",[t._v("空间复杂度")])]),t._v(" "),e("h3",{attrs:{id:"大o符号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大o符号","aria-hidden":"true"}},[t._v("#")]),t._v(" 大O符号")]),t._v(" "),e("p",[t._v("大O符号中指定的算法的增长顺序。")]),t._v(" "),e("p",[e("img",{attrs:{src:_(198),alt:"Big O graphs"}})]),t._v(" "),e("p",[t._v("源: "),e("a",{attrs:{href:"http://bigocheatsheet.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Big O Cheat Sheet"),e("OutboundLink")],1),t._v(".")]),t._v(" "),e("p",[t._v("以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("大O标记法")]),t._v(" "),e("th",[t._v("计算10个元素")]),t._v(" "),e("th",[t._v("计算100个元素")]),t._v(" "),e("th",[t._v("计算1000个元素")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("O(1)")])]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("1")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("O(log N)")])]),t._v(" "),e("td",[t._v("3")]),t._v(" "),e("td",[t._v("6")]),t._v(" "),e("td",[t._v("9")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("O(N)")])]),t._v(" "),e("td",[t._v("10")]),t._v(" "),e("td",[t._v("100")]),t._v(" "),e("td",[t._v("1000")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("O(N log N)")])]),t._v(" "),e("td",[t._v("30")]),t._v(" "),e("td",[t._v("600")]),t._v(" "),e("td",[t._v("9000")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("O(N^2)")])]),t._v(" "),e("td",[t._v("100")]),t._v(" "),e("td",[t._v("10000")]),t._v(" "),e("td",[t._v("1000000")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("O(2^N)")])]),t._v(" "),e("td",[t._v("1024")]),t._v(" "),e("td",[t._v("1.26e+29")]),t._v(" "),e("td",[t._v("1.07e+301")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("O(N!)")])]),t._v(" "),e("td",[t._v("3628800")]),t._v(" "),e("td",[t._v("9.3e+157")]),t._v(" "),e("td",[t._v("4.02e+2567")])])])]),t._v(" "),e("h3",{attrs:{id:"数据结构操作的复杂性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构操作的复杂性","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据结构操作的复杂性")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("数据结构")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("连接")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("查找")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("插入")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("删除")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("数组")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("栈")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("队列")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("链表")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("哈希表")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("-")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("二分查找树")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("B树")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("红黑树")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("AVL树")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])])])]),t._v(" "),e("h3",{attrs:{id:"数组排序算法的复杂性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组排序算法的复杂性","aria-hidden":"true"}},[t._v("#")]),t._v(" 数组排序算法的复杂性")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("名称")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("最优")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("平均")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("最坏")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("内存")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("稳定")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[e("strong",[t._v("冒泡排序")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("插入排序")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("选择排序")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("堆排序")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("归并排序")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("快速排序")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),t._v(" "),e("tr",[e("td",[e("strong",[t._v("希尔排序")])]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("取决于差距序列")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("n (log(n))^2")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])])])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("https://leetcode-cn.com/problemset/all/")])]),t._v(" "),e("li",[e("p",[t._v("https://leetcode-cn.com/problemset/algorithms/")])]),t._v(" "),e("li",[e("p",[t._v("https://leetcode-cn.com/problemset/database/")])]),t._v(" "),e("li",[e("p",[t._v("https://leetcode-cn.com/problemset/shell/")])]),t._v(" "),e("li",[e("p",[t._v("https://www.cnblogs.com/grandyang/p/4606334.html")])]),t._v(" "),e("li",[e("p",[t._v("https://www.kancloud.cn/kancloud/data-structure-and-algorithm-notes/72897")])])])])},[],!1,null,null,null);r.options.__file="readme.md";v.default=r.exports}}]);