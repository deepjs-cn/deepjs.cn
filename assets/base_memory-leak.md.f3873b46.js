import{_ as l,o as e,c as a,V as i}from"./chunks/framework.75ed6a74.js";const o=JSON.parse('{"title":"内存泄漏","description":"","frontmatter":{},"headers":[{"level":2,"title":"内存泄漏的识别方法","slug":"内存泄漏的识别方法","link":"#内存泄漏的识别方法","children":[]},{"level":2,"title":"常见内存泄漏场景","slug":"常见内存泄漏场景","link":"#常见内存泄漏场景","children":[]},{"level":2,"title":"识别内存泄漏","slug":"识别内存泄漏","link":"#识别内存泄漏","children":[]},{"level":2,"title":"WeakMap","slug":"weakmap","link":"#weakmap","children":[]}],"relativePath":"base/memory-leak.md","filePath":"base/memory-leak.md"}'),r={name:"base/memory-leak.md"},t=[i('<h1 id="内存泄漏" tabindex="-1">内存泄漏 <a class="header-anchor" href="#内存泄漏" aria-label="Permalink to &quot;内存泄漏&quot;">​</a></h1><p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</p><h2 id="内存泄漏的识别方法" tabindex="-1">内存泄漏的识别方法 <a class="header-anchor" href="#内存泄漏的识别方法" aria-label="Permalink to &quot;内存泄漏的识别方法&quot;">​</a></h2><p>怎样可以观察到内存泄漏呢？</p><p><a href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications" target="_blank" rel="noreferrer">经验法则</a>是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。</p><h2 id="常见内存泄漏场景" tabindex="-1">常见内存泄漏场景 <a class="header-anchor" href="#常见内存泄漏场景" aria-label="Permalink to &quot;常见内存泄漏场景&quot;">​</a></h2><ol><li>意外的全局变量 <ol><li>为未声明的变量赋值</li><li>使用指向全局对象的 this</li></ol></li><li>计时器和回调函数 timers, 未执行 clear</li><li>DOM 泄漏 <ol><li>给 DOM 对象添加的属性是一个对象的引用</li><li>元素引用没有清理 <ol><li>DOM 节点具有来自 JavaScript 的直接引用，它将防止对其进行垃圾收集，即使在从 DOM 树中删除该节点之后也是如此。</li></ol></li><li>事件的绑定没有移除</li></ol></li><li>事件监听器 <ol><li>活动事件侦听器将防止在其范围内捕获的所有变量被垃圾收集。添加后，事件侦听器将一直有效，直到： <ol><li>使用 removeEventListener() 显式删除。</li><li>关联的 DOM 元素被移除。</li></ol></li></ol></li><li>js 闭包 <ol><li>闭包在 IE6 下会造成内存泄漏，但是现在已经无须考虑了。</li><li>闭包本身不会造成内存泄漏，但闭包过多很容易导致内存泄漏。</li></ol></li><li>console <ol><li>传递给 console.log 的对象是不能被垃圾回收（打开 devtool 时）</li></ol></li><li>缓存 <ol><li>不断地将内存添加到缓存中，而不删除未使用的对象</li></ol></li></ol><p>闭包导致内存泄漏</p><p>那该如何防止这个问题呢？闭包是不可避免的，也是 JavaScript 不可或缺的一部分，因此重要的是：</p><p>了解何时创建闭包以及闭包保留了哪些对象。 了解闭包的预期寿命和用法 (尤其是用作回调时)。</p><h2 id="识别内存泄漏" tabindex="-1">识别内存泄漏 <a class="header-anchor" href="#识别内存泄漏" aria-label="Permalink to &quot;识别内存泄漏&quot;">​</a></h2><ol><li>使用性能分析器可视化内存消耗</li><li>识别分离的 DOM 节点</li></ol><h2 id="weakmap" tabindex="-1">WeakMap <a class="header-anchor" href="#weakmap" aria-label="Permalink to &quot;WeakMap&quot;">​</a></h2><p>及时清除引用非常重要。</p><p>ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个&quot;Weak&quot;，表示这是弱引用。</p>',15)];const n=l(r,[["render",function(l,i,o,r,n,s){return e(),a("div",null,t)}]]);export{o as __pageData,n as default};
