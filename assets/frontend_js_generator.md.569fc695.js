import{_ as e,o as r,c as o,V as t}from"./chunks/framework.75ed6a74.js";const a=JSON.parse('{"title":"生成器函数 Generator","description":"","frontmatter":{},"headers":[{"level":3,"title":"Generator 的特点","slug":"generator-的特点","link":"#generator-的特点","children":[]}],"relativePath":"frontend/js/generator.md","filePath":"frontend/js/generator.md"}'),n={name:"frontend/js/generator.md"},d=[t('<h1 id="生成器函数-generator" tabindex="-1">生成器函数 Generator <a class="header-anchor" href="#生成器函数-generator" aria-label="Permalink to &quot;生成器函数 Generator&quot;">​</a></h1><p>在 Javascript 最初的规则中中，一个函数开始执行后，就会运行到最后或遇到 return 时结束,运行期间不会有其它代码能够打断它。而 ES6 中引入的 Generator（生成器）函数打破了这个规则，Generator 函数可以<code>交出函数的执行权</code>（暂停执行），这也是和普通函数最大的区别。</p><h3 id="generator-的特点" tabindex="-1">Generator 的特点 <a class="header-anchor" href="#generator-的特点" aria-label="Permalink to &quot;Generator 的特点&quot;">​</a></h3><ul><li>调用 Generator 函数，会返回一个<code>内部指针</code>（遍历器 Iterator 对象）</li><li>通过调用 遍历器 <code>Iterator</code> 对象 的 <code>next</code> 方法，遍历 <code>Generator</code> 函数<code>内部的每一个状态</code> -创建时通过 在 function 关键字与函数名添加 &quot;*&quot; 用以和普通函数做区分</li><li>函数体内通过多个 <code>yield</code> 表达式，<code>定义不同的内部状态</code>，遍历器对象 使用 <code>next</code> 遍历时即返回当前的 <code>yield</code> 状态</li></ul><p>Generator 函数 本质上就是协程的一种实现，协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上<code>同时只能执行一个协程</code>。</p>',5)];const c=e(n,[["render",function(e,t,a,n,c,l){return r(),o("div",null,d)}]]);export{a as __pageData,c as default};
