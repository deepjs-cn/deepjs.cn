import{_ as e,o as l,c as a,V as i}from"./chunks/framework.75ed6a74.js";const n=JSON.parse('{"title":"异步","description":"","frontmatter":{},"headers":[{"level":2,"title":"css 的加载","slug":"css-的加载","link":"#css-的加载","children":[]},{"level":2,"title":"JS 的加载","slug":"js-的加载","link":"#js-的加载","children":[]},{"level":2,"title":"改变外链 JS 的加载时机、顺序","slug":"改变外链-js-的加载时机、顺序","link":"#改变外链-js-的加载时机、顺序","children":[{"level":3,"title":"消息队列：是 V8 引擎 除了主线程任务外，额外维护的一个队列，主要存放要执行的任务（函数）","slug":"消息队列-是-v8-引擎-除了主线程任务外-额外维护的一个队列-主要存放要执行的任务-函数","link":"#消息队列-是-v8-引擎-除了主线程任务外-额外维护的一个队列-主要存放要执行的任务-函数","children":[]},{"level":3,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[]},{"level":3,"title":"node 的 EventLoop","slug":"node-的-eventloop","link":"#node-的-eventloop","children":[]}]}],"relativePath":"base/async/index.md","filePath":"base/async/index.md"}'),o={name:"base/async/index.md"},t=[i('<h1 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h1><h2 id="css-的加载" tabindex="-1">css 的加载 <a class="header-anchor" href="#css-的加载" aria-label="Permalink to &quot;css 的加载&quot;">​</a></h2><ul><li>CSS 文件是并行下载的</li><li>CSS 的下载不会阻塞后面 JS 的下载，CSS 加载解析完成之后，再执行下面的 JS。</li></ul><h2 id="js-的加载" tabindex="-1">JS 的加载 <a class="header-anchor" href="#js-的加载" aria-label="Permalink to &quot;JS 的加载&quot;">​</a></h2><ul><li>并行加载 JS 文件</li><li>加载或者执行 JS 时会阻塞构建 DOM 树，只有等到 js 执行完毕，浏览器才会继续解析 DOM。没有 DOM 树，浏览器就无法渲染。</li><li>这是由于 JS 引擎线程 与 GUI 渲染线程 互斥。至于互斥的初衷，主要是因为加载的 JS 中可能会创建，删除节点等，这些操作会对 DOM 树 产生影响，如果不阻塞，等浏览器解析完标签生成 DOM 树后，JS 修改了某些节点，那么浏览器又得重新解析，然后重新生成 DOM 树</li></ul><h2 id="改变外链-js-的加载时机、顺序" tabindex="-1">改变外链 JS 的加载时机、顺序 <a class="header-anchor" href="#改变外链-js-的加载时机、顺序" aria-label="Permalink to &quot;改变外链 JS 的加载时机、顺序&quot;">​</a></h2><ul><li>defer 和 async 都是异步的，主要的区别在于执行顺序以及执行的时间</li><li>async 标志的脚本文件一旦加载完成就会立即执行，并且不会按照书写顺序，谁下载好了就直接执行</li><li>defer 标志的脚本文件会严格按照书写顺序执行，并且，会在 DOMContentLoaded 事件之前执行</li></ul><h3 id="消息队列-是-v8-引擎-除了主线程任务外-额外维护的一个队列-主要存放要执行的任务-函数" tabindex="-1">消息队列：是 V8 引擎 除了主线程任务外，额外维护的一个队列，主要存放要执行的任务（函数） <a class="header-anchor" href="#消息队列-是-v8-引擎-除了主线程任务外-额外维护的一个队列-主要存放要执行的任务-函数" aria-label="Permalink to &quot;消息队列：是 V8 引擎 除了主线程任务外，额外维护的一个队列，主要存放要执行的任务（函数）&quot;">​</a></h3><h3 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h3><ul><li>主线程运行产生了执行栈，在调用执行栈的过程中调用了一些异步函数。</li><li>当满足异步函数的触发条件时，会将对应的回调函数推送到消息队列中。</li><li>当主栈中的代码执行完毕时，会触发一次页面渲染，然后创建新的主栈。</li><li>将消息队列中的回调函数推送到主栈。然后顺序执行主栈的任务。</li><li>反复循环执行上述过程就是时间循环。</li></ul><p>一开始整段脚本作为第一个宏任务执行 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空 执行浏览器 UI 线程的渲染工作 检查是否有 Web worker 任务，有则执行 执行队首新的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空</p><h3 id="node-的-eventloop" tabindex="-1">node 的 EventLoop <a class="header-anchor" href="#node-的-eventloop" aria-label="Permalink to &quot;node 的 EventLoop&quot;">​</a></h3><ul><li>执行 定时器回调 的阶段</li><li>轮询 (英文叫 poll) 阶段</li><li>check 阶段</li></ul><p>timer 阶段 I/O 异常回调阶段 空闲、预备状态 (第 2 阶段结束，poll 未触发之前) poll 阶段 check 阶段 关闭事件的回调阶段</p><p>浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段之间执行的。</p><p>process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行</p>',16)];const s=e(o,[["render",function(e,i,n,o,s,r){return l(),a("div",null,t)}]]);export{n as __pageData,s as default};
