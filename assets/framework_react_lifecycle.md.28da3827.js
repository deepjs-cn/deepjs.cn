import{_ as e,o as t,c as o,V as r}from"./chunks/framework.75ed6a74.js";const a=JSON.parse('{"title":"React lifecycle","description":"","frontmatter":{},"headers":[{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"详解生命周期","slug":"详解生命周期","link":"#详解生命周期","children":[{"level":3,"title":"constructor()","slug":"constructor","link":"#constructor","children":[]},{"level":3,"title":"static getDerivedStateFromProps(nextProps, prevState)","slug":"static-getderivedstatefromprops-nextprops-prevstate","link":"#static-getderivedstatefromprops-nextprops-prevstate","children":[]},{"level":3,"title":"render()","slug":"render","link":"#render","children":[]},{"level":3,"title":"componentDidMount()","slug":"componentdidmount","link":"#componentdidmount","children":[]},{"level":3,"title":"shouldComponentUpdate(nextProps, nextState)","slug":"shouldcomponentupdate-nextprops-nextstate","link":"#shouldcomponentupdate-nextprops-nextstate","children":[]},{"level":3,"title":"getSnapshotBeforeUpdate(prevProps, prevState)","slug":"getsnapshotbeforeupdate-prevprops-prevstate","link":"#getsnapshotbeforeupdate-prevprops-prevstate","children":[]},{"level":3,"title":"componentDidUpdate(prevProps, prevState, snapshot)","slug":"componentdidupdate-prevprops-prevstate-snapshot","link":"#componentdidupdate-prevprops-prevstate-snapshot","children":[]},{"level":3,"title":"componentWillUnmount()","slug":"componentwillunmount","link":"#componentwillunmount","children":[]}]},{"level":2,"title":"生命周期执行顺序","slug":"生命周期执行顺序","link":"#生命周期执行顺序","children":[]}],"relativePath":"framework/react/lifecycle.md","filePath":"framework/react/lifecycle.md"}'),n={name:"framework/react/lifecycle.md"},l=[r('<h1 id="react-lifecycle" tabindex="-1">React lifecycle <a class="header-anchor" href="#react-lifecycle" aria-label="Permalink to &quot;React lifecycle&quot;">​</a></h1><p>生命周期参见下图</p><ul><li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noreferrer">react 生命周期</a></li></ul><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><ul><li>创建挂载 <ul><li><code>constructor</code> 🔥</li><li><code>static getDerivedStateFromProps(nextProps, state)</code></li><li><code>render</code> 🔥</li><li><code>componentDidMount</code> 🔥</li></ul></li><li>更新 <ul><li><code>static getDerivedStateFromProps(nextProps, state)</code></li><li><code>shouldComponentUpdate</code> 🔥</li><li><code>render</code></li><li><code>getSnapshotBeforeUpdate</code></li><li><code>componentDidUpdate</code> 🔥</li></ul></li><li>卸载 <ul><li><code>componentWillUnmount</code> 🔥</li></ul></li><li>异常捕获 <ul><li>static getDerivedStateFromError(error)</li><li>componentDidCatch(error, errorInfo)</li></ul></li></ul><p>React 从 v16.3 开始废弃 <code>componentWillMount</code> <code>componentWillReceiveProps</code> <code>componentWillUpdate</code> 三个钩子函数</p><h2 id="详解生命周期" tabindex="-1">详解生命周期 <a class="header-anchor" href="#详解生命周期" aria-label="Permalink to &quot;详解生命周期&quot;">​</a></h2><h3 id="constructor" tabindex="-1">constructor() <a class="header-anchor" href="#constructor" aria-label="Permalink to &quot;constructor()&quot;">​</a></h3><ul><li>super 的作用：将父类的 this 对象继承给子类 (<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noreferrer">MDN 参考</a>)</li><li>如果不初始化 state 或不进行方法绑定，则不需要写 constructor()，只需要设置 this.state 即可</li><li>不能在 constructor() 构造函数内部调用 this.setState(), 因为此时第一次 render()还未执行，也就意味 DOM 节点还未挂载</li></ul><h3 id="static-getderivedstatefromprops-nextprops-prevstate" tabindex="-1">static getDerivedStateFromProps(nextProps, prevState) <a class="header-anchor" href="#static-getderivedstatefromprops-nextprops-prevstate" aria-label="Permalink to &quot;static getDerivedStateFromProps(nextProps, prevState)&quot;">​</a></h3><p>根据 nextProps 和 prevState 计算出预期的状态改变，返回结果（一个对象）会被送给 setState 更新 state，返回 null 则不更新 state</p><p>注意: <code>getDerivedStateFromProps</code> 是一个静态函数，不能使用 <code>this</code>，应该是一个纯函数，也就是只能作一些无副作用的操作</p><p>使用场景，这个方法就是提供了一个机会，可以根据<strong>新 props</strong> 和 <strong>旧 state</strong> 来调整新的 state</p><p>为什么要这样做？请移步 <a href="https://zhuanlan.zhihu.com/p/38030418" target="_blank" rel="noreferrer">Morgan 大佬 - 知乎</a></p><h3 id="render" tabindex="-1">render() <a class="header-anchor" href="#render" aria-label="Permalink to &quot;render()&quot;">​</a></h3><p>是 <code>class</code> 组件中唯一必须实现的方法，用于渲染 <code>dom</code>，<code>render()</code> 方法必须返回 reactDOM</p><p>不要在 <code>render</code> 里面 <code>setState</code>, 否则会触发死循环导致内存崩溃</p><h3 id="componentdidmount" tabindex="-1">componentDidMount() <a class="header-anchor" href="#componentdidmount" aria-label="Permalink to &quot;componentDidMount()&quot;">​</a></h3><p><code>componentDidMount()</code> 再组件挂在后（插入 DOM 树后）立即调用，<code>componentDidMount()</code> 是发送网络请求、启用事件监听方法的好时机，并且可以在此钩子函数里直接调用 <code>setState</code></p><h3 id="shouldcomponentupdate-nextprops-nextstate" tabindex="-1">shouldComponentUpdate(nextProps, nextState) <a class="header-anchor" href="#shouldcomponentupdate-nextprops-nextstate" aria-label="Permalink to &quot;shouldComponentUpdate(nextProps, nextState)&quot;">​</a></h3><p><code>shouldComponentUpdate()</code> 在组件更新之前调用，可以控制组件是否进行更新， 返回 true 时组件更新， 返回 false 则不更新</p><p>可以根据更新前后的 props 或 state 来比较加一些限制条件，决定是否更新，进行性能优化</p><div class="info custom-block"><p class="custom-block-title">注意</p><p>不建议在 <code>shouldComponentUpdate()</code> 中进行深层比较或实用<code>JSON.stringify()</code>。这样非常影响效率，且会损害性能。</p><p>不要 <code>shouldComponentUpdate()</code> 中调用 setState()，否则会导致无限循环调用更新、渲染，直至浏览器内存崩溃</p><p>可以使用内置 <code>PureComponent</code> 组件替代</p></div><h3 id="getsnapshotbeforeupdate-prevprops-prevstate" tabindex="-1">getSnapshotBeforeUpdate(prevProps, prevState) <a class="header-anchor" href="#getsnapshotbeforeupdate-prevprops-prevstate" aria-label="Permalink to &quot;getSnapshotBeforeUpdate(prevProps, prevState)&quot;">​</a></h3><p>在最近一次的渲染输出被提交之前调用。也就是说在 render 之后，即将对组件进行挂载时调用。</p><p>它可以使组件在 DOM 真正更新之前捕获一些信息（例如滚动位置），此生命周期返回的任何值都会作为参数传递给 <code>componentDidUpdate()</code> 第三个参数。如果不需要传递任何值，那么请返回 null</p><h3 id="componentdidupdate-prevprops-prevstate-snapshot" tabindex="-1">componentDidUpdate(prevProps, prevState, snapshot) <a class="header-anchor" href="#componentdidupdate-prevprops-prevstate-snapshot" aria-label="Permalink to &quot;componentDidUpdate(prevProps, prevState, snapshot)&quot;">​</a></h3><p>会在更新后被立即调用。首次渲染不会执行。</p><p>可以进行前后 props 的比较进行条件语句的限制，来进行 setState，否则会导致死循环。</p><h3 id="componentwillunmount" tabindex="-1">componentWillUnmount() <a class="header-anchor" href="#componentwillunmount" aria-label="Permalink to &quot;componentWillUnmount()&quot;">​</a></h3><p>在组件即将被卸载或销毁时进行调用。</p><p>此生命周期是<strong>取消网络请求、移除监听事件、清理 DOM 元素、清理定时器</strong>等操作的好时机</p><h2 id="生命周期执行顺序" tabindex="-1">生命周期执行顺序 <a class="header-anchor" href="#生命周期执行顺序" aria-label="Permalink to &quot;生命周期执行顺序&quot;">​</a></h2><ul><li>子组件自身状态改变，不会对父组件产生副作用的情况下，父组件不会进行更新（无生命周期触发）</li><li>父组件中状态发生变化（包括子组件的挂载以及卸载）时，会触发自身对应的生命周期以及子组件的更新 <ul><li>render 以及 render 之前的生命周期，则父组件先执行</li><li>render 以及 render 之后的生命周期，则子组件先执行，并且是与父组件交替执行</li></ul></li></ul><p>当子组件进行卸载时，只会执行自身的 <code>componentWillUnmount</code> 生命周期，不会再触发别的生命周期。</p><p>参考</p><ul><li><a href="https://juejin.cn/post/6914112105964634119" target="_blank" rel="noreferrer">深入详解 React 生命周期</a></li></ul>',37)];const p=e(n,[["render",function(e,r,a,n,p,d){return t(),o("div",null,l)}]]);export{a as __pageData,p as default};
