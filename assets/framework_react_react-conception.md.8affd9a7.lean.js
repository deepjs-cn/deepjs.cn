import{_ as s,H as n,o as a,c as l,C as p,a as e,J as o,V as t}from"./chunks/framework.75ed6a74.js";const r=JSON.parse('{"title":"React 中涉及的基本概念","description":"","frontmatter":{},"headers":[{"level":3,"title":"JSX","slug":"jsx","link":"#jsx","children":[]},{"level":3,"title":"ReactElement 结构","slug":"reactelement-结构","link":"#reactelement-结构","children":[]},{"level":3,"title":"Fiber 结构","slug":"fiber-结构","link":"#fiber-结构","children":[]},{"level":3,"title":"JSX, ReactElement, Fiber 及 DOM 的关系","slug":"jsx-reactelement-fiber-及-dom-的关系","link":"#jsx-reactelement-fiber-及-dom-的关系","children":[]},{"level":3,"title":"React 的启动","slug":"react-的启动","link":"#react-的启动","children":[]},{"level":3,"title":"react 初始化时的三个全局对象","slug":"react-初始化时的三个全局对象","link":"#react-初始化时的三个全局对象","children":[]},{"level":3,"title":"update 与 UpdateQueue 对象","slug":"update-与-updatequeue-对象","link":"#update-与-updatequeue-对象","children":[]},{"level":3,"title":"Hook","slug":"hook","link":"#hook","children":[]},{"level":2,"title":"scheduler 包","slug":"scheduler-包","link":"#scheduler-包","children":[{"level":3,"title":"Task 对象","slug":"task-对象","link":"#task-对象","children":[]}]}],"relativePath":"framework/react/react-conception.md","filePath":"framework/react/react-conception.md"}'),c={name:"framework/react/react-conception.md"},y=t("",12),D=p("p",null,[e("legacy 模式: ReactDOM.render("),p("code",null,"<App />"),e(", rootNode) 方法将组件渲染到指定的 DOM 节点上。这种模式不支持并发渲染，因此可能会导致页面卡顿和性能问题。")],-1),F=p("img",{src:"/assets/conception-step-1.be437423.png",alt:"第一步"},null,-1),i=p("li",null,[e("react 初始化 "),p("img",{src:"/assets/conception-step-2.15ad4820.png",alt:"初始化"})],-1),C=p("li",null,[e("此时 reactElement("),p("code",null,"<App/>"),e(")还是独立在外的, 还没有和目前创建的 3 个全局对象关联起来 "),p("img",{src:"/assets/conception-step-3.1369c699.png",alt:"对象关系图"})],-1),A=p("li",null,[e("目前 ReactElement, Fiber 及 DOM 三者之间的关系，fiber 树的构造过程就是把 ReactElement 转换为 fiber 树的过程，这个过程中内存中有 2 棵 fiber 树 "),p("ul",null,[p("li",null,"fiberRoot.current 为当前界面的 fiber 树，如果还没有渲染，那么 fiberRoot.current = null"),p("li",null,"正在构建的 fiber 树，节点为 workInProgress, 挂载到 HostRootFiber.alternage 上，构造完成后，重新渲染页面，最后切换 fiberRoot.current = workInProgress")])],-1),b=p("li",null,[p("p",null,[e("Blocking 模式: ReactDOM.unstable_createBlockingRoot(rootNode).render("),p("code",null,"<App />"),e(")，React 会先渲染完整个应用，然后再将其挂载到 DOM 上。这种模式能够提高应用的渲染性能，但也可能会导致首屏渲染时间过长。")])],-1),u=p("li",null,[p("p",null,[e("Concurrent 模式: ReactDOM.createRoot(rootNode).render("),p("code",null,"<App />"),e(")，会采用异步渲染的方式，将应用的渲染过程分成多个优先级不同的任务，并根据任务的优先级和可用时间动态地调整任务的执行顺序。这种模式可以提高应用的响应速度和用户体验，但也需要开发者仔细设计应用的架构和组件。")])],-1),d=t("",10);const m=s(c,[["render",function(s,t,r,c,m,f){const h=n("App");return a(),l("div",null,[y,p("ul",null,[p("li",null,[D,p("ul",null,[p("li",null,[e("在没有进入 render 阶段（react-reconciler 包）之前,reactElement("),o(h),e(")和 DOM 对象 div#root 之间没有关联。"),F]),i,C,A])]),b,u]),d])}]]);export{r as __pageData,m as default};
