import{_ as e,o as l,c as t,V as r}from"./chunks/framework.75ed6a74.js";const i=JSON.parse('{"title":"Fetch","description":"","frontmatter":{},"headers":[{"level":2,"title":"fetch 兼容性","slug":"fetch-兼容性","link":"#fetch-兼容性","children":[{"level":3,"title":"需要引入 folyfill","slug":"需要引入-folyfill","link":"#需要引入-folyfill","children":[]}]},{"level":2,"title":"fetch Request","slug":"fetch-request","link":"#fetch-request","children":[]},{"level":2,"title":"fetch Response","slug":"fetch-response","link":"#fetch-response","children":[]},{"level":2,"title":"读取内容的方法","slug":"读取内容的方法","link":"#读取内容的方法","children":[]},{"level":2,"title":"参考文档","slug":"参考文档","link":"#参考文档","children":[]}],"relativePath":"best-practices/request/fetch.md","filePath":"best-practices/request/fetch.md"}'),s={name:"best-practices/request/fetch.md"},a=[r('<h1 id="fetch" tabindex="-1">Fetch <a class="header-anchor" href="#fetch" aria-label="Permalink to &quot;Fetch&quot;">​</a></h1><ul><li>fetch 使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</li><li>fetch 采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</li><li>fetch 通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</li></ul><h2 id="fetch-兼容性" tabindex="-1"><a href="https://caniuse.com/fetch" target="_blank" rel="noreferrer">fetch 兼容性</a> <a class="header-anchor" href="#fetch-兼容性" aria-label="Permalink to &quot;[fetch 兼容性](https://caniuse.com/fetch)&quot;">​</a></h2><ul><li>safari 10.3+</li><li>Edge 14+</li><li>ie11- 都不支持</li></ul><h3 id="需要引入-folyfill" tabindex="-1">需要引入 folyfill <a class="header-anchor" href="#需要引入-folyfill" aria-label="Permalink to &quot;需要引入 folyfill&quot;">​</a></h3><ul><li><a href="https://www.npmjs.com/package/whatwg-fetch" target="_blank" rel="noreferrer">whatwg-fetch</a></li><li><a href="https://github.com/taylorhakes/promise-polyfill" target="_blank" rel="noreferrer">promise-polyfill</a></li></ul><p>更多参见</p><ul><li><a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noreferrer">Fetch 规范</a></li><li><a href="https://github.com/web-platform-tests/wpt/tree/master/fetch" target="_blank" rel="noreferrer">Fetch 测试用例</a></li></ul><h2 id="fetch-request" tabindex="-1">fetch Request <a class="header-anchor" href="#fetch-request" aria-label="Permalink to &quot;fetch Request&quot;">​</a></h2><ul><li>Request.method</li><li>Request.headers</li><li>Request.credentials</li><li>Request.cache</li><li>Request.body</li><li>Request.context</li><li>Request.mode</li></ul><h2 id="fetch-response" tabindex="-1">fetch Response <a class="header-anchor" href="#fetch-response" aria-label="Permalink to &quot;fetch Response&quot;">​</a></h2><ul><li>Response.ok [boolean] 是否成功 <ul><li>true: 对应状态码 200~299</li><li>false: 对应其他状态码</li></ul></li><li>Response.status [number] HTTP 回应的状态码</li><li>Response.statusText [string] HTTP 回应的状态信息</li><li>Response.url [string] 返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</li><li>Response.type [string] 返回请求的 类型 <ul><li>basic：普通请求，即同源请求。</li><li>cors：跨域请求。</li><li>error：网络错误，主要用于 Service Worker。</li><li>opaque：如果 fetch() 请求的 type 属性设为 no-cors，就会返回这个值，详见请求部分。表示发出的是简单的跨域请求，类似<code>&lt;form&gt;</code>表单的那种跨域请求。</li><li>opaqueredirect：如果 fetch() 请求的 redirect 属性设为 manual，就会返回这个值，详见请求部分。</li></ul></li><li>Response.redirected [boolean] 请求是否发生过跳转</li><li>Response.headers 指向一个 Headers 对象，对应 HTTP 回应的所有标头。 <ul><li>可以使用<code>for...of</code>循环进行遍历</li></ul></li><li>Response.body 属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。 <ul><li>可以用来分块读取内容，应用之一就是显示下载的进度。</li><li>response.body.getReader() 方法返回一个遍历器。这个遍历器的 read() 方法每次返回一个对象，表示本次读取的内容块。</li></ul></li></ul><p>fetch() 发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，fetch() 才会报错，其他情况都不会报错，而是认为请求成功。</p><h2 id="读取内容的方法" tabindex="-1">读取内容的方法 <a class="header-anchor" href="#读取内容的方法" aria-label="Permalink to &quot;读取内容的方法&quot;">​</a></h2><p>Response 对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p><ul><li>response.text()：得到文本字符串。如 HTML 文件</li><li>response.json()：得到 JSON 对象。主要用于获取接口返回的 json 数据</li><li>response.blob()：得到二进制 Blob 对象。如图片文件</li><li>response.formData()：得到 FormData 表单对象。主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器</li><li>response.arrayBuffer()：得到二进制 ArrayBuffer 对象。主要用于获取流媒体文件，如音频文件</li></ul><p>Stream 对象只能读取一次，读取完就没了。这意味着，上面的五个读取方法，只能使用一个，否则会报错。</p><p>Response 对象提供 Response.clone() 方法，创建 Response 对象的副本，实现多次读取。</p><p>Response 对象还有一个 Response.redirect() 方法，用于将 Response 结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面</p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><ul><li><a href="https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html" target="_blank" rel="noreferrer">https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html</a></li><li><a href="https://blog.logrocket.com/axios-vs-fetch-best-http-requests/" target="_blank" rel="noreferrer">https://blog.logrocket.com/axios-vs-fetch-best-http-requests/</a></li><li><a href="https://www.quora.com/Why-should-JavaScript-developers-prefer-Axios-over-Fetch" target="_blank" rel="noreferrer">https://www.quora.com/Why-should-JavaScript-developers-prefer-Axios-over-Fetch</a></li><li><a href="https://github.com/rikmms/progress-bar-4-axios" target="_blank" rel="noreferrer">https://github.com/rikmms/progress-bar-4-axios</a></li></ul>',21)];const o=e(s,[["render",function(e,r,i,s,o,h){return l(),t("div",null,a)}]]);export{i as __pageData,o as default};
