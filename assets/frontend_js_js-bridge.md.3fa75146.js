import{_ as t,o as e,c as a,V as d}from"./chunks/framework.75ed6a74.js";const i=JSON.parse('{"title":"jsBridge 让 Web 端和 Native 端得以实现双向通信","description":"","frontmatter":{},"headers":[{"level":3,"title":"Native 向 Web 发送消息","slug":"native-向-web-发送消息","link":"#native-向-web-发送消息","children":[]},{"level":3,"title":"Web 向 Native 发送消息","slug":"web-向-native-发送消息","link":"#web-向-native-发送消息","children":[]},{"level":3,"title":"拦截式","slug":"拦截式","link":"#拦截式","children":[]},{"level":3,"title":"注入式","slug":"注入式","link":"#注入式","children":[]}],"relativePath":"frontend/js/js-bridge.md","filePath":"frontend/js/js-bridge.md"}'),r={name:"frontend/js/js-bridge.md"},l=[d('<h1 id="jsbridge-让-web-端和-native-端得以实现双向通信" tabindex="-1">jsBridge 让 Web 端和 Native 端得以实现双向通信 <a class="header-anchor" href="#jsbridge-让-web-端和-native-端得以实现双向通信" aria-label="Permalink to &quot;jsBridge 让 Web 端和 Native 端得以实现双向通信&quot;">​</a></h1><p>WebView 是移动端中的一个控件，它为 JS 运行提供了一个沙箱环境。WebView 能够加载指定的 url，拦截页面发出的各种请求等各种页面控制功能，JSB 的实现就依赖于 WebView 暴露的各种接口。</p><h3 id="native-向-web-发送消息" tabindex="-1">Native 向 Web 发送消息 <a class="header-anchor" href="#native-向-web-发送消息" aria-label="Permalink to &quot;Native 向 Web 发送消息&quot;">​</a></h3><p>Native 向 Web 发送消息基本原理：在 WebView 容器中动态地执行一段 JS 脚本，通常情况下是调用一个挂载在全局上下文的方法。</p><table><thead><tr><th>Android 版本</th><th>API</th><th>特点</th></tr></thead><tbody><tr><td>低版本</td><td>WebView.loadUrl</td><td>无法执行回调</td></tr><tr><td>高版本</td><td>WebView.evaluateJavascript</td><td>可以拿到 JS 执行完毕的返回值</td></tr></tbody></table><table><thead><tr><th>iOS 版本</th><th>API</th><th>特点</th></tr></thead><tbody><tr><td>低版本</td><td>UIWebView.stringByEvaluatingJavaScriptFromString</td><td>无法执行回调</td></tr><tr><td>高版本</td><td>WKWebView.evaluateJavaScript</td><td>可以拿到 JS 执行完毕的返回值</td></tr></tbody></table><p>Native 端可以直接调用挂载在 window 上的全局方法并传入相应的函数执行参数，并且在函数执行结束后 Native 端可以直接<code>拿到执行成功的返回值</code>。</p><h3 id="web-向-native-发送消息" tabindex="-1">Web 向 Native 发送消息 <a class="header-anchor" href="#web-向-native-发送消息" aria-label="Permalink to &quot;Web 向 Native 发送消息&quot;">​</a></h3><p>Web 向 Native 发送消息本质上就是某段 JS 代码的执行<code>端上</code>是可感知的，目前业界主流的实现方案有两种，分别是<code>拦截式</code>和<code>注入式</code>。 WebView 中发出的所有请求都是可以被 Native 容器感知到的，</p><p>「Native 拦截请求的钩子方法：」</p><table><thead><tr><th>平台</th><th>API</th></tr></thead><tbody><tr><td>Android</td><td>shouldOverrideUrlLoading</td></tr><tr><td>iOS 8+</td><td>decidePolicyForNavigationAction</td></tr><tr><td>iOS 8-</td><td>shouldStartLoadWithRequest</td></tr></tbody></table><h3 id="拦截式" tabindex="-1">拦截式 <a class="header-anchor" href="#拦截式" aria-label="Permalink to &quot;拦截式&quot;">​</a></h3><h4 id="通过何种方式发出请求" tabindex="-1">通过何种方式发出请求？ <a class="header-anchor" href="#通过何种方式发出请求" aria-label="Permalink to &quot;通过何种方式发出请求？&quot;">​</a></h4><p>Web 端发出请求的方式非常多样，例如 a.href、iframe.src、location.href、ajax 等</p><ul><li>a.href 需要用户手动触发</li><li>location.href 可能会导致页面跳转</li><li>安卓端拦截 ajax 的能力有所欠缺</li><li>因此绝大多数拦截式实现方案均采用 <code>iframe</code> 来发送请求。</li></ul><h4 id="如何规定-jsb-的请求格式" tabindex="-1">如何规定 JSB 的请求格式？ <a class="header-anchor" href="#如何规定-jsb-的请求格式" aria-label="Permalink to &quot;如何规定 JSB 的请求格式？&quot;">​</a></h4><ul><li>URL 由 <code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;&lt;path&gt;</code> 组成，JSB 的实现借鉴这一思路，定制业务自身专属的一个 URL scheme 来作为 JSB 请求的标识</li></ul><p>但现在该方案已经逐步被淘汰</p><ul><li>连续发送时可能会造成消息丢失（可以使用消息队列解决该问题）</li><li>URL 字符串长度有限制</li><li>性能一般，URL request 创建请求有一定的耗时</li></ul><h3 id="注入式" tabindex="-1">注入式 <a class="header-anchor" href="#注入式" aria-label="Permalink to &quot;注入式&quot;">​</a></h3><p>「Native 注入 API 的相关方法：」</p><table><thead><tr><th>「平台」</th><th>「API」</th><th>「特点」</th></tr></thead><tbody><tr><td>Android</td><td>addJavascriptInterface</td><td>4.2 版本以下有安全风险</td></tr><tr><td>iOS 8+</td><td>WKScriptMessageHandler</td><td>无</td></tr><tr><td>iOS 7+</td><td>JavaSciptCore</td><td>无</td></tr></tbody></table><h4 id="如何执行回调" tabindex="-1">如何执行回调？ <a class="header-anchor" href="#如何执行回调" aria-label="Permalink to &quot;如何执行回调？&quot;">​</a></h4><p>类似 JSONP 的实现，我们可以在请求的 URL 上拼接回调方法的事件名，将该事件挂载在全局 window 上，由于 Native 端可以轻松执行 JS 代码，因此在完成端逻辑后直接执行该事件名对应的回调方法即可</p>',24)];const h=t(r,[["render",function(t,d,i,r,h,o){return e(),a("div",null,l)}]]);export{i as __pageData,h as default};
