import{_ as e,o,c as s,V as l}from"./chunks/framework.75ed6a74.js";const a=JSON.parse('{"title":"hooks","description":"","frontmatter":{},"headers":[{"level":3,"title":"Hooks 的由来是什么？","slug":"hooks-的由来是什么","link":"#hooks-的由来是什么","children":[]},{"level":3,"title":"React hooks 有哪些？","slug":"react-hooks-有哪些","link":"#react-hooks-有哪些","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"深入理解","slug":"深入理解","link":"#深入理解","children":[]},{"level":3,"title":"hooks 实现原理","slug":"hooks-实现原理","link":"#hooks-实现原理","children":[]},{"level":3,"title":"其他 APIs","slug":"其他-apis","link":"#其他-apis","children":[]}],"relativePath":"framework/react/hooks.md","filePath":"framework/react/hooks.md"}'),c={name:"framework/react/hooks.md"},t=[l('<h1 id="hooks" tabindex="-1">hooks <a class="header-anchor" href="#hooks" aria-label="Permalink to &quot;hooks&quot;">​</a></h1><p>整理 React 所有 hooks 相关问题</p><ol><li>Hooks 的由来是什么？</li><li>React Hooks 有哪些，都是做什么的？</li><li><code>useRef</code> 的高级用法是什么？</li><li><code>useMemo</code> 和 <code>useCallback</code> 什么区别？是怎么做优化的？从本质上说，<code>useCallback(fn, deps)</code> 就是<code>useMemo(() =&gt; fn, deps)</code> 的语法糖：</li><li>一个好的自定义 Hooks 该如何设计？</li><li>如何做一个不需要 <code>useState</code> 就可以直接修改属性并刷新视图的自定义 Hooks？</li><li>如何做一个可以监听任何事件的自定义 Hooks？</li><li><code>useEffect</code> 与 <code>useLayoutEffect</code>，怎么做到的？</li></ol><h3 id="hooks-的由来是什么" tabindex="-1">Hooks 的由来是什么？ <a class="header-anchor" href="#hooks-的由来是什么" aria-label="Permalink to &quot;Hooks 的由来是什么？&quot;">​</a></h3><p>react-hooks 是 React16.8 以后新增的钩子 API，目的是增加代码的可复用性、逻辑性，最主要的是解决了函数式组件无状态的问题，这样既保留了函数式的简单，又解决了没有数据管理状态的缺陷。</p><h3 id="react-hooks-有哪些" tabindex="-1">React hooks 有哪些？ <a class="header-anchor" href="#react-hooks-有哪些" aria-label="Permalink to &quot;React hooks 有哪些？&quot;">​</a></h3><p>截止到现在，已经有 22 个 Hooks 了。</p><ul><li>react 包导出了 21 个</li><li>react-dom 包导出了 1 个 (<code>useFormStatus</code>)</li></ul><h4 id="react" tabindex="-1">react <a class="header-anchor" href="#react" aria-label="Permalink to &quot;react&quot;">​</a></h4><p>截止当前，React 的发展主要经历了 3 个时期 👇</p><ol><li>CSR 时期（客户端渲染时期）</li><li>并发时期</li><li>RSC 时期（服务端组件时期）</li></ol><p>当前的 hooks 也都是这 3 个时期的产物</p><h4 id="csr-时期" tabindex="-1">CSR 时期 <a class="header-anchor" href="#csr-时期" aria-label="Permalink to &quot;CSR 时期&quot;">​</a></h4><pre><code>与状态的流转相关的👇\n</code></pre><ol><li><p><code>useState</code></p></li><li><p><code>useReducer</code></p></li><li><p><code>useContext</code></p><p>与处理副作用相关的 👇</p></li><li><p><code>useEffect</code></p></li><li><p><code>useLayoutEffect</code></p><p>与提高操作自由度相关的 👇</p></li><li><p><code>useRef</code></p><p>与性能优化相关的 👇</p></li><li><p><code>useMemo</code></p></li><li><p><code>useCallback</code></p><p>与调试相关的 👇</p></li><li><p><code>useDebugValue</code></p><p>为了完善 CSR 的<strong>并发模式</strong>，对现有 hooks 能力进行补充或约束</p></li><li><p><code>useImperativeHandle</code>（控制 <code>useRef</code> 防止其丢失）</p></li><li><p><code>useEffectEvent</code>（对 <code>useEffect</code> 能力的补充）</p></li><li><p><code>useInsertionEffect</code>（对 <code>useEffect</code> 场景的补充）</p></li><li><p><code>useMemoCache</code>（减少性能优化心智负担）👇</p><p>FC 中的两个性能优化的 hook，存在比较重的心智负担，比如</p><ol><li>开发者需要考虑是否需要性能优化</li><li>开发者需要考虑何时使用 <code>useMemo</code>, <code>useCallback</code></li></ol><p>为了解决这个问题，在 2021 年的 React Conf，黄玄带来了「能够通过编译器生成等效于 <code>useMemo</code>、<code>useCallback</code> 代码」的方案 —— React Forget。</p><p><code>useMemoCache</code> 就是 React 内部为 React Forget 提供缓存支持的 hook。</p><p>所以这个 hook 是给编译器用的，而不是我们普通开发者。</p><p><strong>并发时期</strong>，随着并发特性落地，首先推出的是两个并发相关的 hook</p></li><li><p><code>useTransition</code></p></li><li><p><code>useDeferredValue</code></p><p>👆 这两个 hook，本质都是降低更新的优先级，「更新」意味着「视图渲染」，所以当更新拥有不同优先级后，这意味着「视图渲染」拥有不同优先级。</p><p>这就是并发更新的理论基础。</p><p>但是，并发更新的出现，打破了 React 沿袭多年的「一次更新对应一次渲染」的模式。</p><p>为了让现有的库兼容并发模式，推出了如下 hook：</p></li><li><p><code>useMutableSource</code></p></li><li><p><code>useSyncExternalStore</code></p><p>所以，👆 上述 2 个 hook 主要是面向开源库作者。</p><p><strong>RSC 时期</strong> RSC（服务端组件）是一个浩大的工程</p></li><li><p><code>useId</code></p><p>在并发时期，由于引入了「渲染优先级」的概念，那势必存在一些由于优先级不足，而处于 <code>pending</code> 中的渲染。</p><p>如何展示「渲染的 <code>pending</code> 状态」呢？React 引入了 <code>&lt;Suspense&gt;</code> 组件。</p><p>到了 RSC 时期，React 团队发现，「渲染的 <code>pending</code> 状态」是 <code>pending</code>，「数据请求的 <code>pending</code> 状态」不也是 <code>pending</code> 吗？</p><p>换言之，任何需要中间 <code>pending</code> 状态的流程，不都可以纳入 <code>&lt;Suspense&gt;</code> 的管理范围？</p><p>那该怎么标记一个流程可以被纳入 <code>&lt;Suspense&gt;</code> 的管理呢？于是有了：</p></li><li><p><code>use</code></p><p>👆 通过这个 hook 声明的流程中的 pending 状态都会被纳入 <code>&lt;Suspense&gt;</code> 的管理。</p><p>既然 <code>&lt;Suspense&gt;</code> 越来越重要，那我们是不是要针对他做些优化？既然 <code>&lt;Suspense&gt;</code> 可以在不同视图之间切换，那为他增加缓存显然是种不错的优化方式，于是有了：</p></li><li><p><code>useCacheRefresh</code>（用于建立 <code>&lt;Suspense&gt;</code> 缓存）</p><p>到这一步，RSC 的基础设施算是搭好了，下一步该构建上层应用了。</p><p>在浏览器端，与 RSC 理念最契合的便是 form 标签，围绕 form 标签的 action 属性，React 推出了如下 hook：</p></li><li><p><code>useOptimistic</code></p></li><li><p><code>useFormStatus</code></p><p>👆 这 2 个 hook 都是为了优化「表单提交」这一场景（也可以说是 RSC 与客户端的交互场景）。</p></li><li><p><code>use-sync-external-store</code></p><p>👆 官方还使用独立包提供了这个 hook, 使用同步的外部存储，这是向后兼容的垫片 React.useSyncExternalStore。适用于任何支持 Hooks 的 React。</p><p>zustand 就是基于此来实现的</p></li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>如果说 CSR 时期的 hook 都是面向开发者直接使用的。那么并发时期最初的 2 个 hook（<code>useTransition</code>、<code>useDeferredValue</code>）已经鲜有开发者使用了，而后期类似 <code>useMutableSource</code> 这样的 hook，普通开发者则根本用不到。</p><p>同样的，再往后的 RSC 时期的所有 hook，普通开发者都用不到。他们都是为其他库、框架（比如 Next.js）提供的。</p><p>这标志着 React 发展方向的不断变化：</p><ul><li>早期，定位是前端框架，主要为了解决 facebook 自身问题，顺便开源，受众是开发者</li><li>中期，定位是底层 UI 库，受众是开源库作者</li><li>当前，定位是 web 底层操作系统，受众是上层全栈框架</li></ul><h3 id="深入理解" tabindex="-1">深入理解 <a class="header-anchor" href="#深入理解" aria-label="Permalink to &quot;深入理解&quot;">​</a></h3><h4 id="class-组件的不足" tabindex="-1">class 组件的不足 <a class="header-anchor" href="#class-组件的不足" aria-label="Permalink to &quot;class 组件的不足&quot;">​</a></h4><ul><li>难以复用组件间状态逻辑</li><li>难以维护复杂组件</li><li>this 指向问题 (class 的方法默认不会绑定 this)</li><li>难以对 class 进行编译优化</li></ul><p><strong>Hook 的优势</strong></p><ul><li>无需改变组件结构的情况下复用状态逻辑（自定义 Hook）</li><li>将组件中互相关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li><li>在非 class 的情况下可以使用更多的 React 特性</li></ul><p><strong>Hook 使用规则</strong></p><p>Hook 就是 Javascript 函数，使用它们时有两个额外的规则：</p><ul><li>只能在函数外层调用 Hook，不要在循环、条件判断或者子函数中调用</li><li>只能在 React 的函数组件和自定义 Hook 中调用 Hook。不要在其他 JavaScript 函数中调用</li></ul><p>在组件中 React 是通过判断 Hook 调用的顺序来判断某个 <code>state</code> 对应的 <code>useState</code> 的，所以必须保证 Hook 的调用顺序在多次渲染之间保持一致，React 才能正确地将内部 <code>state</code> 和对应的 Hook 进行关联</p><h4 id="usestate-vs-usereducer" tabindex="-1"><code>useState</code> vs <code>useReducer</code> <a class="header-anchor" href="#usestate-vs-usereducer" aria-label="Permalink to &quot;`useState` vs `useReducer`&quot;">​</a></h4><p><code>useState</code> 用于在函数组件中调用给组件添加一些内部状态 <code>state</code>，唯一的参数就是初始 <code>state</code>，会返回当前状态和一个状态更新函数</p><p><code>useReducer</code> 作为 <code>useState</code> 的代替方案，在某些场景下使用更加适合，例如 <code>state</code> 逻辑较复杂且包含多个子值，或者下一个 <code>state</code> 依赖于之前的 <code>state</code> 等。</p><p>使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为父组件可以向子组件传递 <code>dispatch</code> 而不是回调函数</p><h4 id="useeffect-vs-uselayouteffect" tabindex="-1"><code>useEffect</code> vs <code>useLayoutEffect</code> <a class="header-anchor" href="#useeffect-vs-uselayouteffect" aria-label="Permalink to &quot;`useEffect` vs `useLayoutEffect`&quot;">​</a></h4><p>在函数组件主体内（React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</p><p><code>useEffect</code> Hook 的使用则是用于完成此类副作用操作。<code>useEffect</code> 接收一个包含命令式、且可能有副作用代码的函数</p><p><code>useEffect</code> 函数会在浏览器完成布局和绘制之后，下一次重新渲染之前执行，保证不会阻塞浏览器对屏幕的更新</p><p><code>useEffect</code> Hook 函数执行时机类似于 class 组件的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 生命周期，不同的是传给 <code>useEffect</code> 的函数会在浏览器完成布局和绘制之后，下一次重新渲染之前，进行异步执行，保证不会阻塞浏览器对屏幕的更新。<code>useEffect</code> 返回一个清除函数，类似 <code>componentDidUnmount</code>，会在组件卸载前执行。</p><p><code>useEffect</code> 可以接收第二个参数，它是 effect 所依赖的值数组，这样就只有当数组值发生变化才会重新创建订阅。但需要注意的是：</p><ul><li>确保数组中包含了<strong>所有外部作用域中会发生变化且在 effect 中使用的变量</strong></li><li>传递一个空数组作为第二个参数可以使 effect 只会在初始渲染完成后执行一次</li></ul><p><code>useLayoutEffect</code> 在浏览器重新绘制屏幕之前触发。</p><h4 id="usecontext" tabindex="-1"><code>useContext</code> <a class="header-anchor" href="#usecontext" aria-label="Permalink to &quot;`useContext`&quot;">​</a></h4><p>Context 提供了一个无需为每层组件手动添加 <code>props</code> ，就能在组件树间进行数据传递的方法，<code>useContext</code> 用于函数组件中订阅上层 <code>context</code> 的变更，可以获取上层 <code>context</code> 传递的 value prop 值</p><p><code>useContext</code> 接收一个 <code>context</code> 对象（<code>React.createContext</code> 的返回值）并返回 <code>context</code> 的当前值，当前的 <code>context</code> 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value prop</code> 决定</p><p><code>useContext(MyContext)</code> 相当于 class 组件中的 <code>static contextType = MyContext</code> 或者 <code>&lt;MyContext.Consumer&gt;</code></p><p>调用了 <code>useContext</code> 的组件都会在 <code>context</code> 值变化时重新渲染，为了减少重新渲染组件的较大开销，可以通过使用 memoization 来优化</p><h4 id="useref-vs-createref" tabindex="-1"><code>useRef</code> vs <code>createRef</code> <a class="header-anchor" href="#useref-vs-createref" aria-label="Permalink to &quot;`useRef` vs `createRef`&quot;">​</a></h4><ul><li><code>createRef</code> 每次渲染都会返回一个新的引用</li><li>而 <code>useRef</code> 每次都会返回相同的引用。</li></ul><p><code>useRef</code> 用于返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）</p><p><code>useRef</code> 创建的 <code>ref</code> 对象就是一个普通的 JavaScript 对象，而 <code>useRef</code>() 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 <code>ref</code> 对象</p><p>使用场景（useRef 高级用法）</p><ul><li>用 ref 引用一个值（改变 ref 不会触发重新渲染，可用于缓存数据，获取最新值）</li><li>通过 ref 操作 DOM（获取对应元素的相关属性）</li><li>避免重复创建 ref 的内容（高昂开销的初始化）</li></ul><p>无法获取自定义组件的 ref？</p><p>将其包装在 forwardRef 里，父级组件就可以得到它的 ref。</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">forwardRef</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyInput </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">forwardRef</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">value</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">onChange</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">ref</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">} </span><span style="color:#C792EA;">onChange</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">onChange</span><span style="color:#89DDFF;">} </span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">ref</span><span style="color:#89DDFF;">} /&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> MyInput</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="warning custom-block"><p class="custom-block-title">注意</p><p><strong>不要在渲染期间写入 或者读取 <code>ref.current</code></strong>。</p><p>你可以在 <strong>事件处理程序或者 effects</strong> 中读取和写入 ref。</p><p>如果 <strong>不得不</strong> 在渲染期间读取 或者写入，使用 state 代替。</p></div><h4 id="react-memo-vs-usememo-vs-usecallback" tabindex="-1"><code>React.memo</code> vs <code>useMemo</code> vs <code>useCallback</code> <a class="header-anchor" href="#react-memo-vs-usememo-vs-usecallback" aria-label="Permalink to &quot;`React.memo` vs `useMemo` vs `useCallback`&quot;">​</a></h4><p><code>React.memo()</code> 随 React v16.6 一起发布。它是一个 <code>HOC</code> 高阶组件，其作用是结合了 <code>PureComponent</code> 纯组件和 <code>componentShouldUpdate</code> 功能，会对传入的 <code>props</code> 进行一次对比，然后根据第二个函数返回值来进一步判断哪些 <code>props</code> 需要更新</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MemoizedComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">memo</span><span style="color:#A6ACCD;">(SomeComponent</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> arePropsEqual</span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>使用 <code>memo</code> 将组件包装起来，以获得该组件的一个 记忆化 版本。通常情况下，只要该组件的 <code>props</code> 没有改变（默认情况下，React 将使用 <code>Object.is</code> 比较每个 <code>prop</code>），这个记忆化版本就不会在其父组件重新渲染时重新渲染。但 React 仍可能会重新渲染它：记忆化是一种性能优化，而非保证。</p><p><code>useCallback</code> 和 <code>useMemo</code> 结合 <code>React.Memo</code> 方法的使用是常见的性能优化方式，可以避免由于父组件状态变更导致不必要的子组件进行重新渲染</p><ul><li><code>useMemo</code> 返回的是函数运行的结果</li><li><code>useCallback</code> 返回的是函数</li></ul><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p><p>使用注意：</p><ul><li>传入 <code>useMemo</code> 的函数会在渲染期间执行，不要在这个函数内部执行与渲染无关的操作</li><li>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值</li></ul><h4 id="自定义-hooks-该如何设计" tabindex="-1">自定义 hooks 该如何设计？ <a class="header-anchor" href="#自定义-hooks-该如何设计" aria-label="Permalink to &quot;自定义 hooks 该如何设计？&quot;">​</a></h4><p>hooks 本质上是一个函数，而这个函数主要就是逻辑复用</p><p>自定义 hooks 的名称是以 <code>use</code> 开头</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">xxx</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> setXXX</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">useXXX</span><span style="color:#A6ACCD;">(x1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> x2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="hooks-实现原理" tabindex="-1">hooks 实现原理 <a class="header-anchor" href="#hooks-实现原理" aria-label="Permalink to &quot;hooks 实现原理&quot;">​</a></h3><p>手写实现 useState</p><h3 id="其他-apis" tabindex="-1">其他 APIs <a class="header-anchor" href="#其他-apis" aria-label="Permalink to &quot;其他 APIs&quot;">​</a></h3><ul><li>react <ul><li>Built-in React APIs <ul><li>createContext</li><li>forwardRef</li><li>lazy</li><li>memo</li><li>startTransition</li></ul></li></ul></li><li>Legacy React APIs <ul><li>children</li><li>cloneElement</li><li>Component</li><li>createElement</li><li>createRef</li><li>isValidElement</li><li>PureComponent</li></ul></li><li>react-dom <ul><li>APIs <ul><li>createPortal</li><li>flushSync</li><li>findDOMNode</li><li>hydrate</li><li>render</li><li>unmountComponentAtNode</li></ul></li><li>client APIs <ul><li>createRoot</li><li>hydrateRoot</li></ul></li></ul></li></ul><p>关于 hooks 还是要熟读官方文档，然后结合三方 hooks 库加深理解，下面是社区比较优秀的 React Hooks utils 库：</p><ul><li><a href="https://github.com/streamich/react-use" target="_blank" rel="noreferrer">react-use</a> 37k star</li><li><a href="https://ahooks.js.org/zh-CN/guide" target="_blank" rel="noreferrer">ahooks</a> 12k star</li></ul><p>参考文 <a href="https://github.com/GpingFeng/gopal-blog/issues/95" target="_blank" rel="noreferrer">ahooks 常见场景的封装</a>，该文是全网最全 ahooks 源码分析篇之一，该系列已整理成文档-<a href="https://gpingfeng.github.io/ahooks-analysis/guide/blog" target="_blank" rel="noreferrer">地址</a>。</p><p>参考</p><ul><li><a href="https://mp.weixin.qq.com/s/qXqlWjULWRMeEEGLizLojw" target="_blank" rel="noreferrer">搞懂这 12 个 Hooks，保证让你玩转 React</a></li><li><a href="https://mp.weixin.qq.com/s/BXwMmOzbWHbeXkBYNJebXw" target="_blank" rel="noreferrer">你可能不知道的流式 React Hooks（关于组织代码的最佳实践）</a></li><li><a href="https://mp.weixin.qq.com/s/PKLJnaygOTl9vmSq2GtExA" target="_blank" rel="noreferrer">React Hooks 完全使用指南</a></li><li>​<a href="https://mp.weixin.qq.com/s/1-M5eMHRBhjJYQvO2wvsqA" target="_blank" rel="noreferrer">不数不知道，React 已经有 22 个 hook 了</a></li></ul>',78)];const n=e(c,[["render",function(e,l,a,c,n,p){return o(),s("div",null,t)}]]);export{a as __pageData,n as default};
