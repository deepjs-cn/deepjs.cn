import{_ as e,o as s,c as l,V as n}from"./chunks/framework.75ed6a74.js";const a=JSON.parse('{"title":"react 构造过程","description":"","frontmatter":{},"headers":[{"level":3,"title":"fiber 更新优化原则","slug":"fiber-更新优化原则","link":"#fiber-更新优化原则","children":[]},{"level":3,"title":"diff 算法介绍","slug":"diff-算法介绍","link":"#diff-算法介绍","children":[]}],"relativePath":"framework/react/react-reconciler.md","filePath":"framework/react/react-reconciler.md"}'),o={name:"framework/react/react-reconciler.md"},c=[n('<h1 id="react-构造过程" tabindex="-1">react 构造过程 <a class="header-anchor" href="#react-构造过程" aria-label="Permalink to &quot;react 构造过程&quot;">​</a></h1><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 需要手动启用Concurrent 模式</span></span>\n<span class="line"><span style="color:#A6ACCD;">ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;"> /&gt;,</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">root</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">unstable_concurrentMode</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 启用 Concurrent 模式</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">unstable_scheduleHydrationTarget</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">root</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// 设置 hydration 目标</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>fiber 树的构造</p><ol><li>除此创建：React 首次启动，页面还没有渲染，直接构造一整棵树</li><li>对比更新：界面已经渲染，场景新的 fiber 之前，需要与旧的 fiber 进行对象</li><li>深度优先遍历 <ol><li>探寻阶段 beginWork <ol><li>根据 ReactElement 对象创建所有的 fiber 节点, 最终构造出 fiber 树形结构(设置 return 和 sibling 指针)</li><li>给节点打标签：设置 fiber.flags(标记 fiber 节点 的增,删,改状态, 等待 completeWork 阶段处理)</li><li>设置真实 DOM 的局部状态：设置 fiber.stateNode 局部状态</li></ol></li><li>回溯阶段 completeWork <ol><li>给 fiber 节点创建 DOM 实例, 设置 fiber.stateNode 局部状态；为 DOM 节点设置属性, 绑定事件(合成事件原理)；设置 fiber.flags 标记</li><li>把当前 fiber 对象的副作用队列(firstEffect 和 lastEffect)添加到父节点的副作用队列之后, 更新父节点的 firstEffect 和 lastEffect 指针.</li><li>判断当前 fiber 是否有副作用(增,删,改), 如果有, 需要将当前 fiber 加入到父节点的 effects 队列, 等待 commit 阶段处理.</li></ol></li></ol></li></ol><p><code>fiber树构造循环</code>负责构造新的 fiber 树, 构造过程中同时标记 <code>fiber.flags</code>, 最终把所有被标记的 fiber 节点<code>收集到一个副作用队列中</code>, 这个副作用队列被挂载到根节点上(<code>HostRootFiber.alternate.firstEffect</code>). 此时的 fiber 树和与之对应的 DOM 节点都还在内存当中, 等待 commitRoot 阶段进行渲染</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">fiber </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  return</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">  sibling</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">  next</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">  tag</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// HostComponent, HostText创建 DOM 实例, 设置fiber.stateNode局部状态</span></span>\n<span class="line"><span style="color:#A6ACCD;">  flags</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 用来标记fiber的增,删,改状态，在complateWork 阶段时使用</span></span>\n<span class="line"><span style="color:#A6ACCD;">  stateNode</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 真实 dom 的局部</span></span>\n<span class="line"><span style="color:#A6ACCD;">  firstEffect</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 副作用队列</span></span>\n<span class="line"><span style="color:#A6ACCD;">  lastEffect</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="fiber-更新优化原则" tabindex="-1">fiber 更新优化原则 <a class="header-anchor" href="#fiber-更新优化原则" aria-label="Permalink to &quot;fiber 更新优化原则&quot;">​</a></h3><ol><li>只对同级节点进行对比，如果 DOM 节点跨层级移动，则 react 不会复用</li><li>不同类型的元素会产出不同的结构，会销毁老的结构，创建新的结构</li><li>可以通过 key 标示移动的元素</li><li>类型一致的节点才有继续 diff 的必要性</li></ol><h3 id="diff-算法介绍" tabindex="-1">diff 算法介绍 <a class="header-anchor" href="#diff-算法介绍" aria-label="Permalink to &quot;diff 算法介绍&quot;">​</a></h3><ol><li>单节点 <ol><li>如果是新增节点, 直接新建 fiber, 没有多余的逻辑</li><li>如果是对比更新 <ol><li>如果 key 和 type 都相同，则复用</li><li>否则新建</li></ol></li></ol></li><li>多节点(多节点一般会存在两轮遍历，第一轮<code>寻找公共序列</code>，第二轮遍历剩余<code>非公共序列</code>) <ol><li>第一次循环 <ol><li><code>key 不同</code>导致不可复用，立即跳出整个遍历，第一轮遍历结束。</li><li>key 相同 <code>type 不同</code>导致不可复用，会将 oldFiber 标记为 <code>DELETION</code>，并继续遍历 <ol><li>如果 <code>newChildren 遍历完（即</code> i === newChildren.length - 1）或者 <code>oldFiber 遍历完</code>（即 oldFiber.sibling === null），跳出遍历，第一轮遍历结束。</li><li>let i = 0，遍历 newChildren，将 <code>newChildren[i]</code>与 <code>oldFiber</code> 比较，判断 DOM 节点是否可复用。如果可复用，i++，继续比较 newChildren[i]与 <code>oldFiber.sibling</code>，可以复用则继续遍历</li><li>如果不可复用，分两种情况：</li></ol></li></ol></li><li>第二次循环: 遍历剩余非公共序列, 优先复用 oldFiber 序列中的节点。 <ol><li>如果 newChildren 与 oldFiber 同时遍历完，diff 结束</li><li>如果 <code>newChildren没遍历完</code>，oldFiber 遍历完，意味着没有可以复用的节点了，遍历剩下的 newChildren 为<code>生成的workInProgress</code> fiber 依次标记<code>Placement</code>。</li><li>如果 newChildren 遍历完，<code>oldFiber没遍历完</code>，意味着有节点被删除了，需要遍历剩下的 oldFiber，依次标记<code>Deletion</code>。</li><li>如果 newChildren 与 oldFiber <code>都没遍历完</code><ol><li>先去<code>声明map数据结构</code>，遍历一遍老节点，把老 fiber 的 key 做映射 {元素的 key：老的 fiber 节点}</li><li>继续遍历新<code>jsx</code>，如果<code>map</code>有<code>key</code>，会把<code>key</code>从<code>map</code>中删除，说明可以复用，把当前节点标记为<code>更新</code>。新地位高的不动，新地位低的动（中间插入链表比链表屁股插入费劲）所以地位低的动动</li><li><code>lastPlaceIndex</code>指针，指向最后一个不需要动的老节点的<code>key</code>。每次新 jsx 复用到节点，<code>lastPlaceIndex</code>会指向老节点的最后一个成功复用的老<code>fiber</code>节点。如果新复用的节点 key 小于<code>lastPlaceIndex</code>，说明老<code>fiber</code>节点的顺序在新<code>jsx</code>之前，需要挪动位置接到新<code>jsx</code>节点后面。</li><li>如果<code>jsx</code>没有复用的老<code>fiber</code>，直接插入新的</li><li><code>map</code>中只剩还没被复用的节点，等着新的<code>jsx</code>数组遍历完，<code>map</code>里面的<code>fiber</code>节点全部设</li></ol></li></ol></li></ol></li></ol>',10)];const i=e(o,[["render",function(e,n,a,o,i,r){return s(),l("div",null,c)}]]);export{a as __pageData,i as default};
