import{_ as l,o as i,c as e,V as r}from"./chunks/framework.75ed6a74.js";const o=JSON.parse('{"title":"从输入 URL 到页面展示到底发生了什么？","description":"","frontmatter":{},"headers":[{"level":3,"title":"步骤","slug":"步骤","link":"#步骤","children":[]},{"level":3,"title":"详解","slug":"详解","link":"#详解","children":[]}],"relativePath":"browser/url-render.md","filePath":"browser/url-render.md"}'),a={name:"browser/url-render.md"},t=[r('<h1 id="从输入-url-到页面展示到底发生了什么" tabindex="-1">从输入 URL 到页面展示到底发生了什么？ <a class="header-anchor" href="#从输入-url-到页面展示到底发生了什么" aria-label="Permalink to &quot;从输入 URL 到页面展示到底发生了什么？&quot;">​</a></h1><ul><li>推荐参考 <a href="https://juejin.cn/post/6935232082482298911" target="_blank" rel="noreferrer">从输入 URL 开始建立前端知识体系</a></li></ul><h3 id="步骤" tabindex="-1">步骤 <a class="header-anchor" href="#步骤" aria-label="Permalink to &quot;步骤&quot;">​</a></h3><ol><li>输入网址并解析 <ol><li>URL 解析</li><li>HSTS</li><li>Service Worker</li><li>浏览器缓存 <ol><li>强缓存</li><li>协商缓存</li></ol></li></ol></li><li>建立连接 <ol><li>DNS 域名解析 <ol><li>递归查询</li><li>迭代查询</li></ol></li><li>TCP/IP 连接：三次握手</li><li><a href="/interview/questions/http.html">HTTP 请求</a><ol><li>HTTP/0.9</li><li>HTTP/1.0</li><li>HTTP/1.1</li><li>HTTP/2</li><li>HTTP/3</li></ol></li><li>HTTPS（TSL 四次握手）</li></ol></li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器渲染页面 <ol><li>DOM 树</li><li>CSS 对象模型 (CSSOM)</li><li>布局树 Layout Tree</li><li>渲染 <ol><li>创建图层</li><li>回流和重绘</li></ol></li><li>首屏加载完成</li><li>可交互</li></ol></li><li>断开连接：TCP 四次挥手</li></ol><h3 id="详解" tabindex="-1">详解 <a class="header-anchor" href="#详解" aria-label="Permalink to &quot;详解&quot;">​</a></h3><ul><li>URL 解析，域名解析。涉及到 DNS 寻址的过程，获取对应的服务器 IP 地址</li><li>缓存检查。首先检查强缓存，其次是协商缓存。 <ul><li>如果强缓存生效，则直接从浏览器缓存获取资源</li><li>如果强缓存失效，则浏览器向服务器发起一个 http 请求，当然这中间还有一个 tcp 三次握手的一个过程。建立连接后，服务器检查资源是否更改，如果没有更改，则返回 304 告诉浏览器读取缓存，否则响应 200 并发送资源文件给浏览器</li></ul></li><li>拿到资源文件后，浏览器开始解析并构建 dom 树和 cssom 树。这中间又涉及两种过程。 <ul><li>如果有 js 脚本，那么 cssom 树的构建会阻塞 js 的执行，js 的执行会阻塞 dom 树的构建</li><li>如果没有 js 脚本，那么 cssom 树的构建和 dom 树的构建是并行的，当然大部分网页都会包含 js 脚本。</li></ul></li><li>有了 cssom 树和 dom 树后，就开始构建 render tree。render tree 并不是和 dom 树一一对应的，render tree 并不包含 display:none 等元素，以及 style，link，head 这些标签。</li><li>构建完 render tree，布局（Layout，也叫重排）阶段会为每个节点计算精确的位置和大小信息。</li><li>布局阶段完成后，就是绘制阶段（paint），将各个节点绘制到屏幕上，页面就呈现出来了。</li></ul>',6)];const s=l(a,[["render",function(l,r,o,a,s,n){return i(),e("div",null,t)}]]);export{o as __pageData,s as default};
